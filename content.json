{"meta":{"title":"吕哲扬的个人博客","subtitle":"世事不是非黑即白","description":"吕哲扬 Louis 前端 React-Native js","author":"吕哲扬","url":"http://ensorrow.github.io"},"pages":[],"posts":[{"title":"微信小程序初探","slug":"微信小程序初探","date":"2016-11-07T07:48:16.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/11/07/微信小程序初探/","link":"","permalink":"http://ensorrow.github.io/2016/11/07/微信小程序初探/","excerpt":"文章目录： 开发环境搭建 应用架构解析 逻辑层 注册程序 注册页面 模块化 API 视图层 数据绑定 条件渲染和列表渲染 模板 事件 引用 WXSS 组件 -微信小程序公测啦！！！-哦。 唉我这么激动周围的人毫无反应，真的是无趣啊。不管了，今天下午终于没课了，就放着要期末的积分变换不管来学这个吧。 本质上来说，我们还是构造了一个webapp，但是微信弃用了安卓卡卡的原生webview，用x5的内核来解析应用的Js（支持ES6哦😯），也不知道性能会如何。大概分为下面这么几块来研究一下这个框架： 开发环境搭建 应用架构 逻辑层 视图层 一、开发环境搭建开发环境搭建特别简单，直接下载开发IDE就行了，直接贴地址。。开发IDE下载。 二、应用架构解析我们从官方给出的Hello World开始讲起吧，首先让我们看看目录结构： pages index index.js index.wxml index.wxss logs logs.js logs.json logs.wxml logs.wxss utils util.js app.js app.json app.wxss 首先可以看到有好几种没见过的后缀，类比过去的话wxml就是html，wxss就是css，按照那样理解就行了（当然是精简修改破解版的）。然后还有一些json，这些是作为配置文件使用的，一会单独讲。项目整体的架构相当清晰简洁（毕竟是helloworld。。），一个应用入口文件app.js，然后多个页面index, logs，一个公用的工具函数存放处utils。","text":"文章目录： 开发环境搭建 应用架构解析 逻辑层 注册程序 注册页面 模块化 API 视图层 数据绑定 条件渲染和列表渲染 模板 事件 引用 WXSS 组件 -微信小程序公测啦！！！-哦。 唉我这么激动周围的人毫无反应，真的是无趣啊。不管了，今天下午终于没课了，就放着要期末的积分变换不管来学这个吧。 本质上来说，我们还是构造了一个webapp，但是微信弃用了安卓卡卡的原生webview，用x5的内核来解析应用的Js（支持ES6哦😯），也不知道性能会如何。大概分为下面这么几块来研究一下这个框架： 开发环境搭建 应用架构 逻辑层 视图层 一、开发环境搭建开发环境搭建特别简单，直接下载开发IDE就行了，直接贴地址。。开发IDE下载。 二、应用架构解析我们从官方给出的Hello World开始讲起吧，首先让我们看看目录结构： pages index index.js index.wxml index.wxss logs logs.js logs.json logs.wxml logs.wxss utils util.js app.js app.json app.wxss 首先可以看到有好几种没见过的后缀，类比过去的话wxml就是html，wxss就是css，按照那样理解就行了（当然是精简修改破解版的）。然后还有一些json，这些是作为配置文件使用的，一会单独讲。项目整体的架构相当清晰简洁（毕竟是helloworld。。），一个应用入口文件app.js，然后多个页面index, logs，一个公用的工具函数存放处utils。 我们从单个页面讲起。比如说Index页面，小程序要求页面文件名和目录名（页面名称）必须一致，所以也不需要在js里做import（这样挺方便的）。看看js文件和模板文件 1234567891011121314151617181920212223242526//index.js//获取应用实例var app = getApp()Page(&#123; data: &#123; motto: 'Hello World', userInfo: &#123;&#125; &#125;, //事件处理函数 bindViewTap: function() &#123; wx.navigateTo(&#123; url: '../logs/logs' &#125;) &#125;, onLoad: function () &#123; console.log('onLoad') var that = this //调用应用实例的方法获取全局数据 app.getUserInfo(function(userInfo)&#123; //更新数据 that.setData(&#123; userInfo:userInfo &#125;) &#125;) &#125;&#125;) 12345678910&lt;!--index.wxml--&gt;&lt;view class=\"container\"&gt; &lt;view bindtap=\"bindViewTap\" class=\"userinfo\"&gt; &lt;image class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt; &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view class=\"usermotto\"&gt; &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 其中Page是框架提供的全局方法，然后和一般的MVVM框架一样，采用了数据绑定，然后也有事件绑定、生命周期这些东西（而且生命周期和应用需求很一致，比如说应用后台，这点很赞），可以看到也有路由跳转（index貌似是默认打开的），视图更新。 下面看看json文件是干什么的，比如说logs.json 123&#123; \"navigationBarTitleText\": \"查看启动日志\"&#125; 因为程序是运行在微信之上的，所以我们给的这些配置就是改一下标题栏颜色啊文字啊这些东西。然后还有一个复杂一些的app.json，这个就看文档配置就好了，要注册page之类的。架构大概就这个样子。 三、逻辑层微信小程序的逻辑层内容相当的简洁，官方文档的TAB就这几个东西 注册程序 注册页面 模块化 API 从应用本身来说呢，我们处理逻辑大概就这几种情境吧： 页面内部的逻辑处理 路由跳转 跨页面的通信 1. 注册程序框架给我们提供了什么呢？首先是 注册程序，也就是全局的App方法（传入一个对象），这个作为应用的主入口，可以监听一些应用生命周期的事件，然后配置一些全局变量，按理说应该还要能配置路由关系。看看我们的App.js 123456789101112131415161718192021222324252627282930//app.jsApp(&#123; onLaunch: function () &#123; //调用API从本地缓存中获取数据 var logs = wx.getStorageSync('logs') || [] logs.unshift(Date.now()) wx.setStorageSync('logs', logs) &#125;, getUserInfo:function(cb)&#123; var that = this if(this.globalData.userInfo)&#123; typeof cb == \"function\" &amp;&amp; cb(this.globalData.userInfo) &#125;else&#123; //调用登录接口 wx.login(&#123; success: function () &#123; wx.getUserInfo(&#123; success: function (res) &#123; that.globalData.userInfo = res.userInfo typeof cb == \"function\" &amp;&amp; cb(that.globalData.userInfo) &#125; &#125;) &#125; &#125;) &#125; &#125;, globalData:&#123; userInfo:null &#125;&#125;) 这里的onLaunch是一个生命周期的事件钩子，然后getUserInfo相当于一个全局的方法（使用getApp()获取实例以后就可以调用，在index.js里就有），globalData作为app的属性自然就担任了全局变量这一角色啦。这里还用到了本地存储这一API，这也是一个体验好的应用必不可少的部分。 2. 注册页面然后是 注册页面。和全局的App方法对应也有一个Page方法用于页面的注册，页面也会有一些生命周期的事件，除此之外还有一个比较特殊的事件：页面下拉刷新 onPullDownRefresh。其他的就是自定义事件处理函数的注册了，见DEMO 1&lt;view bindtap=\"viewTap\"&gt; click me &lt;/view&gt; 12345Page(&#123; viewTap: function() &#123; console.log('view tap') &#125;&#125;) 除了bind+event作为属性名还可以用catch+event，区别在于后者可以阻止继续冒泡。然后事件绑定函数只有一个参数event，但是event包含了该节点的信息所以很方便就能完成各种逻辑定制。 3. 模块化首先要明确的是，目前版本的小程序还不支持node_modules的导入，所以要用的话只能复制源码过去了。和webpack的模块化类似，小程序各个page的作用域是独立的，如果要对外暴露接口的话（比如写公共组件），要使用模块导出 12345678910// common.jsfunction sayHello(name) &#123; console.log(`Hello $&#123;name&#125; !`)&#125;function sayGoodbye(name) &#123; console.log(`Goodbye $&#123;name&#125; !`)&#125;module.exports.sayHello = sayHello// module.exports = &#123; sayHello: sayHello &#125; 结合的ES6的import食用口感更佳。 4. API小程序的API都通过wx这一个全局对象来访问，和运行在浏览器的javascript类似，wx也提供了如HTTP请求，本地存储，绘图这一类的API，除此之外还有一些更为本地化的API，比如拨打电话、重力感应、交互反馈、支付这一类API，非常的方便，具体使用时请查阅小程序API 四、视图层与React Native类似，微信小程序也自制了一套标签（不过要精简的多），称为WXML(WeiXin Markup language)，也同样是基于组件的。与之配合的样式表称为WXSS(WeiXin Style Sheet)。 WXML作为模板语言，少不了数据绑定、条件渲染、列表渲染这些东西，和Vue.js很像，下面简单过一遍。 1. 数据绑定数据绑定采用Mustache语法，也就是双大括号。值的注意的是大括号里支持一些ES6的表达式，比如说展开语法和简化的对象属性写法 1&lt;template is=\"objectCombine\" data=\"&#123;&#123;...obj1, ...obj2, e&#125;&#125;\"&gt;&lt;/template&gt; 12345678910111213Page(&#123; data: &#123; obj1: &#123; a: 1, b: 2 &#125;, obj2: &#123; c: 3, d: 4 &#125;, e: 5 &#125;&#125;) 得到的结果就是{a: 1, b: 2, c: 3, d: 4, e: 5}。 2. 条件渲染和列表渲染条件渲染和列表渲染很简单，就像vue.js里两个指令v-if和v-for，小程序里用的是wx:if和wx:for，用两个简单的DEMO过一下 123456789&lt;!-- 条件渲染 --&gt;&lt;view wx:if=\"&#123;&#123;length &gt; 5&#125;&#125;\"&gt; 1 &lt;/view&gt;&lt;view wx:elif=\"&#123;&#123;length &gt; 2&#125;&#125;\"&gt; 2 &lt;/view&gt;&lt;view wx:else&gt; 3 &lt;/view&gt;&lt;!-- 列表渲染 --&gt;&lt;view wx:for=\"&#123;&#123;array&#125;&#125;\"&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;&lt;/view&gt; 注意一下列表渲染里面的关键字index和item，对应的是数组的下标和元素，如果想自定义关键字的话就这样 123&lt;view wx:for=\"&#123;&#123;array&#125;&#125;\" wx:for-index=\"idx\" wx:for-item=\"itemName\"&gt; &#123;&#123;idx&#125;&#125;: &#123;&#123;itemName.message&#125;&#125;&lt;/view&gt; 还要提到一个block标签，在学RN的时候就觉得为了将几个部分组合起来要套一个View在外面很坑，这里就诞生了一个block标签实现这个需求 1234&lt;block wx:if=\"&#123;&#123;true&#125;&#125;\"&gt; &lt;view&gt; view1 &lt;/view&gt; &lt;view&gt; view2 &lt;/view&gt;&lt;/block&gt; 提到列表渲染就要提到 key 这个东西，因为框架不知道列表元素变了以后是怎么变的，所以对于动态列表需要给列表元素一个独一无二的key，使用wx:key指令提供。指令值可以是一个字符串表示属性名（循环中的item的Property），也可以是关键字*this（如果item不是一个对象的话）。 123456&lt;switch wx:for=\"&#123;&#123;objectArray&#125;&#125;\" wx:key=\"unique\" style=\"display: block;\"&gt; &#123;&#123;item.id&#125;&#125; &lt;/switch&gt;&lt;button bindtap=\"switch\"&gt; Switch &lt;/button&gt;&lt;button bindtap=\"addToFront\"&gt; Add to the front &lt;/button&gt;&lt;switch wx:for=\"&#123;&#123;numberArray&#125;&#125;\" wx:key=\"*this\" style=\"display: block;\"&gt; &#123;&#123;item&#125;&#125; &lt;/switch&gt;&lt;button bindtap=\"addNumberToFront\"&gt; Add to the front &lt;/button&gt; 123456789101112131415161718192021222324252627282930313233343536373839Page(&#123; data: &#123; objectArray: [ &#123;id: 5, unique: 'unique_5'&#125;, &#123;id: 4, unique: 'unique_4'&#125;, &#123;id: 3, unique: 'unique_3'&#125;, &#123;id: 2, unique: 'unique_2'&#125;, &#123;id: 1, unique: 'unique_1'&#125;, &#123;id: 0, unique: 'unique_0'&#125;, ], numberArray: [1, 2, 3, 4] &#125;, switch: function(e) &#123; const length = this.data.objectArray.length for (let i = 0; i &lt; length; ++i) &#123; const x = Math.floor(Math.random() * length) const y = Math.floor(Math.random() * length) const temp = this.data.objectArray[x] this.data.objectArray[x] = this.data.objectArray[y] this.data.objectArray[y] = temp &#125; this.setData(&#123; objectArray: this.data.objectArray &#125;) &#125;, addToFront: function(e) &#123; const length = this.data.objectArray.length this.data.objectArray = [&#123;id: length, unique: 'unique_' + length&#125;].concat(this.data.objectArray) this.setData(&#123; objectArray: this.data.objectArray &#125;) &#125;, addNumberToFront: function(e)&#123; this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray) this.setData(&#123; numberArray: this.data.numberArray &#125;) &#125;&#125;) 3. 模板还是和RN一样，因为View这些标签语义化的限制及组件化的要求，我们很多时候我们会自己定义一个模板来复用，这个直接看DEMO就懂了 12345678&lt;template name=\"msgItem\"&gt; &lt;view&gt; &lt;text&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125; &lt;/text&gt; &lt;text&gt; Time: &#123;&#123;time&#125;&#125; &lt;/text&gt; &lt;/view&gt;&lt;/template&gt;&lt;template is=\"msgItem\" data=\"&#123;&#123;...item&#125;&#125;\"/&gt; 注意模板作用域是独立的，只能使用data属性传入的数据。 4. 事件前面简单提了一下事件的两种绑定方式，现在简单列一下wx支持的一些冒泡事件名称： touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchcancel 手指触摸动作被打断，如来电提醒，弹窗 touchend 手指触摸动作结束 tap 手指触摸后马上离开 longtap 手指触摸后，超过350ms再离开 其余的事件都是不冒泡的，那些就因组件而异了，比如说&lt;form /&gt;的submit等。然后之前也提过，事件参数就只有一个event，所以要传值的时候data-属性就显得很重要了，因为事件对象可以获取到一个dataset对象，对应都是就是各个自定义的data-属性。 5. 视图的引用就像ejs里会有include一样，模板语言肯定是会有引用嵌套的功能的，wx里提供了两种方法，分别是import和include，见DMEO 1234&lt;!-- item.wxml --&gt;&lt;template name=\"item\"&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt;&lt;/template&gt; 12&lt;import src=\"item.wxml\"/&gt;&lt;template is=\"item\" data=\"&#123;&#123;text: 'forbar'&#125;&#125;\"/&gt; 然后是include 123&lt;!-- index.wxml --&gt;&lt;include src=\"header.wxml\"/&gt;&lt;view&gt; body &lt;/view&gt; 12&lt;!-- header.wxml --&gt;&lt;view&gt; header &lt;/view&gt; 6. WXSSWXSS继承了css的大部分特性，同时针对移动端做了一些拓展优化： 尺寸单位 样式导入 尺寸单位是最赞的特性了，WXSS新增了rpx这个单位及重制了rem这个单位。其中使用rpx时，默认按照屏幕宽度750px进行样式编写即可，页面会根据实际页面大小进行缩放。而rem则默认屏幕为20rem宽，同样会自动缩放。 样式导入和css中的写法一样（原理肯定不一样），使用@import ()来进行导入即可。 初次之外，内联样式支持动态更新（数据绑定），选择器目前的支持范围如下： class .intro 选择所有拥有 class=”intro” 的组件 #id #firstname 选择拥有 id=”firstname” 的组件element view 选择所有 view 组件element, element view checkbox 选择所有文档的 view 组件和所有的 checkbox 组件::after view::after 在 view 组件后边插入内容::before view::before 在 view 组件前边插入内容 值得注意的是，在wx中，选择器的优先级概念有差异，不同的page下面的wxss是独立的，只作用于相应页面不会相互覆盖，只有app下面的wxss才是通用的。 7. 组件首先还是要吐槽一下，真的和RN很像。。。wx提供了一系列组件，具体的还是查询官方文档吧~贴地址微信小程序组件 嗯，真的就这么多，感觉这个框架设计的挺好用的。。。","categories":[],"tags":[{"name":"wechat","slug":"wechat","permalink":"http://ensorrow.github.io/tags/wechat/"}],"keywords":[]},{"title":"Angular学习笔记（一）","slug":"Angular学习笔记（一）","date":"2016-11-05T08:45:07.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/11/05/Angular学习笔记（一）/","link":"","permalink":"http://ensorrow.github.io/2016/11/05/Angular学习笔记（一）/","excerpt":"","text":"一、Angular指令与vue、regular中的指令类似，Angular也有一套自己的指令系统，而且更为强大（Angular自我介绍的时候就是说用指令来拓展HTML）。本质上指令还是HTML属性，以ng-开头，下面大概介绍一下几个简单的指令。 ng-app 该指令声明一个angular app（或者模块）的根元素，在网页加载完毕后，ng-app指令会自动初始化应用（模块） ng-init 用于初始化变量，实际应用一般会在controller里，基本用不上吧 ng-repeat 类似于list Angular依赖注入wiki上的解释：依赖注入（Depandency Injection）是一种软件设计模式，在这种模式下，一个或更多的依赖（或服务）被注入（或者通过引用传递的方式）到一个独立的对象中，成为该对象状态的一部分。 这种模式的好处就是可以让程序更加的模块化，一个“服务”只需要实现自己的功能，业务逻辑相关的东西写在controller里而与其无关的基本的一些东西（比如说HTTP请求，本地存储等）都可以设计成一个独立的服务，在业务逻辑需要的时候进行注入。 Angular提供一下5个核心组件用来 作为依赖注入： value factory service provider constant 这几个的使用场景分别是啥呢？我们来一个一个说。 value首先是value，与其名称相一致，用于在配置阶段向一个controller传递值（值的类型应该是随意的吧） 12345var app = angular.module(\"myapp\", []);app.value('mydefault', 'helloworld');app.controller('ctr', function($scope, mydefault) &#123; $scope.yname = mydefault;&#125;) 这里顺便提一下，一个controller拥有独立的作用域，控制一个模块（类似于组件？）。那这里和直接声明var mydefault = &#39;helloworld&#39;有啥区别呢？我猜，既然叫做注入，那这个mydefault的作用域应该是在app内部吧，而且必须在参数里显示的声明他，具体实现机制以后用熟了再说。。 factoryfactory就是工厂函数啦。首先科普一下啥叫工厂函数，所谓工厂呢，就是要生产东西的，如果把基本的数据类型理解成原材料的话，那工厂函数就是能够用这些基本类型造出（或者说拼出？）一个新的类型（集合）出来，所以叫它工厂函数。 在Angular里，factory的角色就是要造出符合实际需要的值，通常我们会在service和controller需要的时候使用factory函数来计算或者返回值，看DEMO 12345678910app.factory('myService', function() &#123; var factory = &#123;&#125;; factory.addon = function(a, b)&#123; return a+b; &#125; return factory;&#125;)app.controller('ctr', function($scope, myService) &#123; console.log(myService.addon(3,5));&#125;) 不过呢，如果我用value来注入一个对象的话不就实现了和这个同样的效果了么。。。有点搞不懂，用着用着应该就明白了。 service在Angular里，你可以自建服务，也可以使用它內建的常用服务，如 1234var app = angular.module('myApp', []);app.controller('customersCtrl', function($scope, $location) &#123; $scope.myUrl = $location.absUrl();&#125;); 上面演示了如何便捷的使用內建的服务，下面还要再看看怎么自建服务 12345app.service('MyService', function() &#123; this.func = function(x) &#123; return x*x; &#125;&#125;) 自建的服务和內建的一样通过参数注入，很简单吧。 providerprovider用于在配置阶段创建一个service、factory等，需要重写$get来返回对应的。。服务？ constant与value类似，只不过定义的是常量而已 1phonecatApp.constant('constanttest', 'this is constanttest'); 然后在控制器等地方应用就行了。","categories":[],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://ensorrow.github.io/tags/Angular/"}],"keywords":[]},{"title":"前端入门-HTML+CSS基础","slug":"前端入门-HTML-CSS基础","date":"2016-09-19T05:08:07.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/09/19/前端入门-HTML-CSS基础/","link":"","permalink":"http://ensorrow.github.io/2016/09/19/前端入门-HTML-CSS基础/","excerpt":"前端最最基础的东西就是静态页面制作，而要制作一个好的静态页面，要求我们熟练掌握HTML+CSS，今天就让我们一起来学习一下这两门前端最基础的语言。 参考教程： W3School 菜鸟教程 CSS教程 一、HTML关于HTML，首先我们得先了解一下它的全称：Hyper Text Markup Language，即超文本 标记语言 。HTML并不是一种编程语言，你不能使用它写出任何可以跑的程序，你只是使用它所提供的一套 标记标签 （markup tag）来描述你的页面，然后把它交给浏览器去解析。也就是说HTML是不需要你去编译的（包括后面的css和JavaScript也是），你甚至可以直接打开windows自带的记事本，用HTML规范的语言写出一个网页然后直接用浏览器打开就能看到正确的结果（当然还是用专业的文本编辑器比较合适。。）。 好吧，对于一个刚刚接触编程的人上面的话可能不好理解，等你以后学过c或者其他编程语言之后再回来看就可以明白上面这段话的意义了。我们先直接看一个什么入门教程都会有的helloworld页面，看看一个HTML页面长什么样： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello &lt;br&gt; World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这是一个最为简单的HTML页面结构，从上到下大概可以分为这么几个部分： 文档类型声明 HTML内容部分 head标签，包含文档的头信息 body标签，包含文档的内容部分 暂且忽略head和类型声明，我们直接从body部分开始入手。","text":"前端最最基础的东西就是静态页面制作，而要制作一个好的静态页面，要求我们熟练掌握HTML+CSS，今天就让我们一起来学习一下这两门前端最基础的语言。 参考教程： W3School 菜鸟教程 CSS教程 一、HTML关于HTML，首先我们得先了解一下它的全称：Hyper Text Markup Language，即超文本 标记语言 。HTML并不是一种编程语言，你不能使用它写出任何可以跑的程序，你只是使用它所提供的一套 标记标签 （markup tag）来描述你的页面，然后把它交给浏览器去解析。也就是说HTML是不需要你去编译的（包括后面的css和JavaScript也是），你甚至可以直接打开windows自带的记事本，用HTML规范的语言写出一个网页然后直接用浏览器打开就能看到正确的结果（当然还是用专业的文本编辑器比较合适。。）。 好吧，对于一个刚刚接触编程的人上面的话可能不好理解，等你以后学过c或者其他编程语言之后再回来看就可以明白上面这段话的意义了。我们先直接看一个什么入门教程都会有的helloworld页面，看看一个HTML页面长什么样： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello &lt;br&gt; World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这是一个最为简单的HTML页面结构，从上到下大概可以分为这么几个部分： 文档类型声明 HTML内容部分 head标签，包含文档的头信息 body标签，包含文档的内容部分 暂且忽略head和类型声明，我们直接从body部分开始入手。 1.标签与元素标签，英文 tag 。如你所见，在之前那个HTML页面里头出现了大量的尖括号 &lt;&gt;包裹起来的东西，这个东西就是一个标签。你也一定注意到了，一部分标签是成对的，如&lt;p&gt;&lt;/p&gt;，一部分标签是不成对的，如&lt;br&gt;。这些有什么区别呢？ 好，如我们之前所提到的，&lt;&gt;尖括号包裹起来的就是一个标签，其中像&lt;p&gt;这样的叫做起始标签，&lt;/p&gt;这种到一个斜杠的叫做结束标签，那么一开一闭就构成了一个 HTML元素，如&lt;p&gt;Hello &lt;br&gt; World!&lt;/p&gt;表示一个段落，其中标签中间的文本就叫做元素的内容。但不是所有的标签都可以构成一个元素，如&lt;br&gt;表示一个换行符，它没有结束标签或者说它的结束标签就是它本身，它就只是一个标签而不是一个HTML元素。而且正如你所见，标签是 支持嵌套 的。（当然p标签里嵌套p标签就不推荐了，没有意义） 标签可以具有 属性 ，属性可以让一个标签包含更多的信息。HTML标签属性以名称/值对的形式提供，如href=&quot;http://www.baidu.com&quot;，且 定义在开始标签里。最为典型的如a标签&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;。 2.常用的HTML标签为了便于理解，这里会先介绍两个比较基础的标签：标题标签和段落标签。（比如在这里就是一个段落标签，上面👆就是一个标题标签） 首先是段落标签p，正如前面Hello World所演示的，直接将一段文本用一个p标签包裹即可得到一个段落：&lt;p&gt;this is a paragraph&lt;/p&gt;。 然后是标题，标题总共分为六级：h1-h6。也就是说从&lt;h1&gt;一级标题&lt;/h1&gt;一直到&lt;h6&gt;六级标题&lt;/h6&gt;，一级标题是最大的标题，六级是最小的。 其他常用的语义化标签有，具体用法请查阅参考教程： 无序列表 &lt;ul&gt;&lt;/ul&gt; 有序列表 &lt;ol&gt;&lt;/ol&gt; 超链接 &lt;a href=&quot;&quot;&gt;&lt;/a&gt; 图片 &lt;img src=&quot;&quot;&gt; 上面说到的都是一些语义化的标签，事实上，在一个网页中总有那么一些部分你是不能明确认定它是标题或是什么的，所以必然会存在一些没有具体语义的、用于纯布局的标签，最典型的两个就是&lt;div&gt;&lt;/div&gt;和&lt;span&gt;&lt;/span&gt;，关于这两个标签的介绍需要涉及到css布局，等到讲CSS的时候再细讲吧。 3.一个简单的DEMO学过上面的东西以后让我们简单写一个小页面 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;e瞳第一次前端培训&lt;/h1&gt; &lt;h3&gt;主讲人：xxx，友情链接：&lt;a href=\"http://www.eeyes.net\"&gt;e瞳网&lt;/a&gt;&lt;/h3&gt; &lt;img src=\"http://www.eeyes.net/v20151125/images/camera.png\"&gt; &lt;p&gt;欢迎加入e瞳前端设计组，我们旗下分为两个部门：&lt;/p&gt; &lt;ol&gt; &lt;li&gt;前端组&lt;/li&gt; &lt;li&gt;设计组&lt;/li&gt; &lt;/ol&gt; &lt;h2&gt;PART1. HTML&lt;/h2&gt; &lt;p&gt;随便填一点内容这是一个段落&lt;/p&gt; &lt;h2&gt;PART2. CSS&lt;/h2&gt; &lt;p&gt;随便填一点内容这是一个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 二、CSS1.修改样式的几种方法好了，学过HTML之后你会发现完全不够，你写出来的页面长得太丑了，而且你完全无法掌控它的样式，所以接下来我们就要学习如何修改一个页面的样式了。在那之前，先了解一下有哪几种修改样式的方法。 第一种，也是最推荐的那一种，就是引入外部样式表，即引入css文件的方法修改样式，如下： 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./css/style.css\"&gt; 然后直接在对应路径的css文件中写样式就可以了。 第二种，不是很推荐但有时很方便的方法，直接修改标签的style属性，又称为修改行内样式，如下： 1&lt;p style=\"font-size: 16px;\"&gt;some text&lt;/p&gt; 第三种，是在head里写一个style标签，里面写样式就可以了，如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; p&#123; font-size: 16px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2.css选择器上面提到的几种方法里最好理解的应该是修改行内样式了吧，直接修改你所需要该样式的标签的style属性就能够实现你的目的，那么另外两种方法呢？如何选中你所想要的标签呢？这里就要用到css选择器了。 基础的css选择器有三种：元素选择器、类选择器、ID选择器。 首先是元素选择器，元素选择器特别简单，直接选择相应的标签名即可： 123456p&#123; font-size:16px;&#125;h1&#123; color:#fff;&#125; 好的，现假设有如下情况：下面的一个列表里第一、三、四项需要修改样式，元素选择器是不是就懵逼了？这个时候需要用到 类选择器，分为两步进行：首先给你想要加样式的标签加一个class属性，然后再使用.class_name来选中对应类名的标签，如下： 12345678&lt;ul&gt; &lt;li class=\"special\"&gt;list item1&lt;/li&gt; &lt;li&gt;list item2&lt;/li&gt; &lt;li class=\"special\"&gt;list item3&lt;/li&gt; &lt;li&gt;list item4&lt;/li&gt; &lt;li class=\"special\"&gt;list item5&lt;/li&gt; &lt;li&gt;list item6&lt;/li&gt;&lt;/ul&gt; 123.special&#123; color: #ccc;&#125; 而有的时候你只想选中一个，那就没有必要使用类选择器了，转而使用 ID选择器，同样也是两步进行：首先给你要选中的标签加上对应的ID，然后再使用#id_name选中： 12345678&lt;ul&gt; &lt;li&gt;list item1&lt;/li&gt; &lt;li id=\"special\"&gt;list item2&lt;/li&gt; &lt;li&gt;list item3&lt;/li&gt; &lt;li&gt;list item4&lt;/li&gt; &lt;li&gt;list item5&lt;/li&gt; &lt;li&gt;list item6&lt;/li&gt;&lt;/ul&gt; 123#special&#123; color: #ccc;&#125; 好了，知道了这三种基础的选择器以后很容易就能理解其他的选择器了，都是根据它们衍生出来的，在这里我只是简单地列一下，具体请查阅参考教程： 关系选择器 后代选择器 相邻兄弟选择器 子元素选择器 属性选择器 伪类选择器 伪元素选择器 * 3.css基础样式在修改样式时常有的需求无非就是修改背景、修改字体、修改大小等等，在这里我们通过一个html文档来简单的列一下，很简单，不详述。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"wrapper\"&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;ul&gt; &lt;li&gt;hhhh&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;link here&lt;/a&gt;&lt;/li&gt; &lt;li&gt;zzzzz&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 背景： 123456789101112#wrapper&#123; width: 200px; height: 200px; /*背景颜色 */ background-color: #ccc; /*背景图片 */ background-image: url(http://www.eeyes.net/v20151125/images/camera.png); background-repeat: no-repeat; background-position: 0 10px; /*背景样式缩写 */ background: url(http://www.eeyes.net/v20151125/images/camera.png) #ccc no-repeat 0 10px;&#125; 文本（注意一下font-family）： 1234567#wrapper p&#123; font-size: 16px; font-family: Times, TimesNR, 'New Century Schoolbook', Georgia, 'New York', serif; color: #fff; text-align: center;&#125; 其他常用： 1234567891011ul&#123; list-style: square; /*列表样式*/&#125;a&#123; color: #000;&#125;a:hover&#123; color: #ccc; /*链接悬浮样式*/&#125; 4.css布局这一块需要当面讲。。","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://ensorrow.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://ensorrow.github.io/tags/CSS/"}],"keywords":[]},{"title":"ES6学习笔记","slug":"ES6学习笔记","date":"2016-08-06T07:47:20.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/08/06/ES6学习笔记/","link":"","permalink":"http://ensorrow.github.io/2016/08/06/ES6学习笔记/","excerpt":"文章目录： let &amp; const 变量的解构赋值 字符串扩展 函数扩展 对象扩展 Set &amp; Map数据结构 ES6虽然用的挺久了，但是一直处于半懂不懂的懵逼状态🙃,急需系统的学习一遍。 本文参考：ECMAScript入门 - 阮一峰 一、let &amp; const1.关于let关于let命令，首先看看它的基本用法（块级作用域）： 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 由此例可见，let所声明的变量只在代码块之内有效，而ES6之前只有全局作用域和函数作用域的概念，此例中var所声明的变量全局有效。let的出现使得一个老问题得到了解决： 123456var s = 'hello';for(var i=0;i&lt;s.length;i++)&#123; console.log(s[i]);&#125;console.log(i); //i=5 事实上我们并不需要这个i（仅作计数），这种情况下就造成了变量名的匮乏（认真脸😐）：取完i取j，取完j取k，k都没有了就用index😂。以后我们直接用let就好了。","text":"文章目录： let &amp; const 变量的解构赋值 字符串扩展 函数扩展 对象扩展 Set &amp; Map数据结构 ES6虽然用的挺久了，但是一直处于半懂不懂的懵逼状态🙃,急需系统的学习一遍。 本文参考：ECMAScript入门 - 阮一峰 一、let &amp; const1.关于let关于let命令，首先看看它的基本用法（块级作用域）： 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 由此例可见，let所声明的变量只在代码块之内有效，而ES6之前只有全局作用域和函数作用域的概念，此例中var所声明的变量全局有效。let的出现使得一个老问题得到了解决： 123456var s = 'hello';for(var i=0;i&lt;s.length;i++)&#123; console.log(s[i]);&#125;console.log(i); //i=5 事实上我们并不需要这个i（仅作计数），这种情况下就造成了变量名的匮乏（认真脸😐）：取完i取j，取完j取k，k都没有了就用index😂。以后我们直接用let就好了。 第二个特性是不存在变量提升： 12345console.log(foo); // 输出undefinedconsole.log(bar); // 报错ReferenceErrorvar foo = 2;let bar = 2; var是有变量提升的概念的，在预解析时用var声明的变量已经进入对应的作用域里了（只是运行到这一行时赋值），值为undefined，而使用let是不存在这个现象的，在声明之前使用是会报错的，事实上这样更为规范也更好控制。 第三个可能会是我们经常遇到的问题，假设存在下面的情况： 123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 全局通过var定义了一个变量，然后又在块级作用域里头用let定义了一个，那么在let定义之前这个变量的值是哪一个呢（这他妈就很尴尬了）？两个都不合理，所以还抛出错误好了。。 这个概念就是暂时性死区。在代码块中，使用let命令声明变量之前，该变量都是不可用的，这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 2.关于constconst，全称目测是constant，即常量，使用const可以声明只读的一个常量 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 常量的值不能被改变，故声明常量时就需要同时把值赋给该常量，不然会报错。 与let类似，const的作用域也是块级的，const也没有变量提升（准确说是常量提升🤔。。）的现象，也同样会存在暂时性死区。 常量并不意味着对应的值不发生改变，对于复合类型的变量，变量名指向数据所在的地址而不是对应地址的值（数据），比如说经常见到的 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 虽说a是只读的，但是a只保存了这个数组的地址，这个数组本身仍然是可写的，更改这个数组没有任何问题，但是对a赋值就是你的不对啦。 总结一下，除了传统的通过var和function声明变量的方法，ES6还添加了let和const命令（后面还会提到有import和class啊），主要的区别在于作用域和变量提升，最后还要提一点，传统的var和function声明的全局变量作为全局对象的属性而存在，通过let、const、class声明的变量不再是全局对象的属性。 1234567var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined 二、变量的解构赋值什么叫解构赋值呢？先来两个基本用法： 12345678910let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3//数组var &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\"//对象，按照属性名对应赋值 传统情况下我们得一个一个手动赋值，代码冗长无趣，现在，终于，解放啦！👻解构赋值还允许我们指定默认值，像这样： 12var [foo = true] = [];foo // true 默认值还可以是表达式，不过要注意的是表达式是惰性求值，就是说只有在用到的时候才会执行这个表达式。另外还有一个特别要注意的点，对于对象的解构赋值,如果要先声明，后赋值的话，为了区分对象与代码块，需要使用小括号包裹赋值语句，如： 12let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功 对象和数组一样是可以嵌套的，但是不同的是， 并不是每一级的变量都会被赋值，上级属性可能只是一个模式（架子），见DEMO： 12345678910111213141516171819202122//ES6var node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;//ES5\"use strict\";var node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;var line = node.loc.start.line; 在这个栗子中，仅line是变量，其他的都是模式，console.log的话会得到ReferenceError:loc is not defined。 不仅仅是数组和对象，字符串也可以进行解构赋值，不过是作为一个类数组对象： 123456const [a, b, c, d, e] = 'hello';a // \"h\"b // \"e\"c // \"l\"d // \"l\"e // \"o\" 三、字符串拓展新增的部分方法增强了对中文的支持，这个暂且用不到。然后这几个可以看一下： includes(),startsWith(),endsWith() 用于判断字符串在另一字符串中的位置，返回布尔值 repeat(),将某一字符串重复几次输出 padStart(),padEnd() 用于字符串补全：&#39;1&#39;.padStart(10, &#39;0&#39;) // &quot;0000000001&quot; 上面的拓展只是为了方便起见，没什么特别大的惊喜，下面这个新特性就令人亦可赛艇了：模板字符串。 以前我们要输出一个模板，需要大量的字符串拼接处理，像下面这样： 123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); 实在是烦不胜烦，现在我们就方便多了： 12345$('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 不仅可以作为普通字符串使用，模板字符串甚至还能够嵌入变量： 1234567//used as normal stringconsole.log(`string text line 1string text line 2`);//嵌入变量var name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 顺带一提如果希望输出不保留换行，使用trim()方法就可以了。在${}内部我们可以放入任意的js表达式，甚至还能嵌套哦！ 模板字符串另一个大用处，就是标签模板，它可以紧跟在一个函数名后面，这个函数将被用来处理这个模板字符串，也就意味着你能在参数里进行复杂的运算处理啦。 四、函数的扩展第一个是参数默认值功能，这个很早之前用RN的时候就用过了😆 1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 参数默认值还可以和解构赋值结合起来，像这样 123456789function fetch(url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125;) &#123; console.log(method);&#125;fetch('http://example.com', &#123;&#125;)// \"GET\"fetch('http://example.com')// 报错 注意：通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的，除非显式输入undefined。 ES6还引入了rest参数，用于获取多余的参数（以前的解决方法貌似是使用特殊变量arguments 123456789function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125; rest参数必须为最后一个参数。与rest参数对应的有扩展运算符...，将一个数组转为用逗号分隔的参数序列。 12345console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5 然后是我们的箭头函数： 12345var f = v =&gt; v;//equal tovar f = function(v)&#123; return v;&#125;; 如果有多个参数且代码块部分有多条语句，可以用括号括起来： 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 箭头函数与变量解构结合起来用： 12345const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125; 使用箭头函数的第一个大优势就是this的绑定。在箭头函数内部是没有自己的this的，导致了内部的this就是外层代码块的this，把箭头函数等价的用ES5写出来就是这样： 123456789101112131415// ES6function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;// ES5function foo() &#123; var _this = this; setTimeout(function () &#123; console.log('id:', _this.id); &#125;, 100);&#125; 这个特性使得其在组件化的时代尤为吃香，因为它可以让this指向组件本身： 123456789101112var handler = &#123; id: '123456', init: function() &#123; document.addEventListener('click', event =&gt; this.doSomething(event.type), false); &#125;, doSomething: function(type) &#123; console.log('Handling ' + type + ' for ' + this.id); &#125;&#125;; 五、对象扩展ES6支持对象属性和方法的简写： 12345678910111213var birth = '2000/01/01';var Person = &#123; name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log('我的名字是', this.name); &#125;&#125;; ES6还支持使用表达式作为属性名和方法名，表达式需要放在方括号内 12345678910var lastWord = 'last word';var a = &#123; 'first word': 'hello', [lastWord]: 'world'&#125;;a['first word'] // \"hello\"a[lastWord] // \"world\"a['last word'] // \"world\" 接下来会有一个常用的方法Object.assign(target, ...source)用于对象的合并，第一个参数是目标对象，后面的参数都是源对象。要注意的是该方法实行的是浅拷贝，目标对象拷贝的只是源对象的引用： 12345var obj1 = &#123;a: &#123;b: 1&#125;&#125;;var obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 对于对象，我们经常需要对它的属性进行遍历，ES6一共提供了5种方法： （1）for…in for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。 （2）Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。 （3）Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。 （4）Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。 （5）Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。 symbol是程序创建并且可以用作属性键的值，并且它能避免命名冲突的风险。调用Symbol()创建一个新的symbol，它的值与其它任何值皆不相等。它是ES6提出的JavaScript的第七种原始类型。 六、Set和Map数据结构ES6新增了两种数据结构Set和Map（以前貌似只有Array和Object），来使我们的各种数据操作更加便利。首先我们来介绍一下Set。 1. SetSet类似于数组，但是要求所有的成员值是唯一的，不能出现重复的值： 12345678var s = new Set();[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x));s //Set &#123;2,3,5,4&#125;for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 Set构造函数可以接受一个数组作为参数，只是会剔除掉其中的重复值。要注意在Set中重复成员的意义为两个值精确相等===（除了NaN自身相等）。 Set实例的属性和方法列举如下： 实例属性 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 操作方法 add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 遍历方法 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 (暂时没get到新数据结构的价值。。) 2.Map暂时用不到，以后补充。","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://ensorrow.github.io/tags/ES6/"}],"keywords":[]},{"title":"正则表达式从入门到放弃","slug":"正则表达式从入门到放弃","date":"2016-08-05T10:48:23.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/08/05/正则表达式从入门到放弃/","link":"","permalink":"http://ensorrow.github.io/2016/08/05/正则表达式从入门到放弃/","excerpt":"","text":"也不知是第多少回看正则表达式了，虽然在周五的夜晚我归心似箭想打开我的《权力的游戏》，但是作为一个即将要做项目的程序猿连正则表达式都用不熟是会被嘲笑的😂，所以还是坐着敲一篇博客吧。 一、元字符所谓元字符，可以理解为正则表达式中具有意义的最小单元，按照其功能，元字符可以分为以下几类： 1. 字符类用于匹配单字符，常用的有： \\w匹配任何ASCII单字符[a-zA-Z0-9] \\W匹配任何ASCII单字符之外的字符（反义） \\s匹配任何Unicode空白符 \\S匹配任何Unicode空白符以外的字符（反义） \\d匹配任何数字[0-9] \\D反义 a or \\u4e00 特定ASCII或Unicode单字符 然后如果匹配的单字符规则比较复杂的话，可以用方括号[...]把多个规则括起来，意指匹配方括号中规则的字符，反义为[^...]，很好理解吧。 2. 重复类重复类使用大括号包裹{}，表示前一项的重复次数，重复次数和普通数组的表示方法完全一致： {n}匹配一项恰好n次 {n,}匹配一项至少n次 {n,m}匹配一项n~m次 除了一般数组的表示方法，还有更为简约的表达： {?}匹配0次或1次（很贴切） {+}至少一次 {*}0次或以上（即任意次，总不能负数次吧） 3. 选择符 &amp; 定位符这两个之所以放在一起讲，是因为它们都偏向于功能和逻辑（而且内容太少了单独讲撑不起来啊😂）。选择符|超级简单，和js当中的||是一个意思，就是 或。定位符呢，主要是以下几种： ^匹配字符串开头 $匹配字符串结尾 \\b匹配单词边界 \\B反义，非单词边界（即存在边界的不匹配匹配不存在边界的） 顺便说一下，一个正则表达式的首尾往往是/，这个和\\转义的斜杠不同，只是作为表达式的特殊容器而已（类似于引号），也没有任何的定位符意义。 二、分组好吧我标题的级别取的有点乱了。。在js中我们经常见到这样的表达式if (exp1 || exp2)，然后在正则里面就是这个样子的(\\d{7}|\\d{8})，相当于把规则分一个组（加上了小括号），不同组之间又可以使用基本的元字符再进行规则制定了。 好吧，太乱了（东西很少，分类不清，暂时够用，多了会忘）。。以后用的多一点的时候再来完善。","categories":[],"tags":[{"name":"正则","slug":"正则","permalink":"http://ensorrow.github.io/tags/正则/"}],"keywords":[]},{"title":"Regular学习笔记(二)","slug":"Regular-js学习笔记-二","date":"2016-08-01T11:47:01.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/08/01/Regular-js学习笔记-二/","link":"","permalink":"http://ensorrow.github.io/2016/08/01/Regular-js学习笔记-二/","excerpt":"PART1. 静态接口一、extend &amp;&amp; implement &amp;&amp; new在实例化一个新的Regular组件时我们总是直接使用 var compnent = Component.extend({options}) 事实上这只是其中的一种方法。根据官方API Reference，静态接口有两种： Component 此接口同时属于Regular及其子类 Regular 此接口只属于Regular本身（一般作为全局配置参数） 一般情况下，我们会这样做： 1234567891011var Component = Regular.extend(&#123; template:` &lt;div&gt;&lt;/div&gt; `, init:function()&#123;&#125;,&#125;)var component = Component.extend(&#123; init: function()&#123; this.supr() &#125;&#125;)","text":"PART1. 静态接口一、extend &amp;&amp; implement &amp;&amp; new在实例化一个新的Regular组件时我们总是直接使用 var compnent = Component.extend({options}) 事实上这只是其中的一种方法。根据官方API Reference，静态接口有两种： Component 此接口同时属于Regular及其子类 Regular 此接口只属于Regular本身（一般作为全局配置参数） 一般情况下，我们会这样做： 1234567891011var Component = Regular.extend(&#123; template:` &lt;div&gt;&lt;/div&gt; `, init:function()&#123;&#125;,&#125;)var component = Component.extend(&#123; init: function()&#123; this.supr() &#125;&#125;) 关于supr的介绍，需要查看https://github.com/ded/klass。其实就相当于将父类的同名方法执行一遍（是不是也可以理解为mixin进去？）。 如果希望将所有Component的子组件都加一个新的方法应该怎么做呢？这时候就要用到implement: Component.implement({ hello: function( msg ){ this.supr( msg ) // call the super hello } }) 除了extend方法之外，我们经常还会直接实例化一个组件 var com = new Component({ data: {} }) 实例化则意味着传入的option将会成为实例的属性，将覆盖extend和implement的同名属性（方法）的定义，并且在创建时无法调用this.supr()。 二、关于options我们在创建组件时传入的option有好多种，在这里统一列一下 template config： 在模板编译之前被调用，一般用来初始化参数，参数为组件的data init 在模板编译之后调用，一般在此处处理与DOM相关的逻辑 destroy： 如果需要自定义回收策略（默认已经有了），可以重写destroy方法，但是记得调用this.supr()来调用默认的回收方法 name： 注册组件到父组件（继承的父组件）的命名空间内，使其可以被内嵌使用。不愿意这么做的话可以使用`Component.component(‘name’, superComponent)来进行注册 events： 在组件初始化之前声明需要绑定的事件 Regular.extend({ events: { &quot;$init&quot;: function(){ // same in component.init }, &quot;$destroy&quot;: function(){ // same in component.destroy } } }) data： 父组件的data最终会被merge到实例化时传入的data（即父组件的data可被视为缺省的data 三、Component.use() 使用插件一个典型的插件写法应该是这样的： function FooPlugin(Componenet){ Component.implement()// implement method .filter() // define filter .directive() // define directive .event() // define custom event } var YourComponent = Regular.extend(); FooPlugin(YourComponent); // lazy bind FooPlugin(Regular); // lazy bind to globals 为了统一，所有的Component都內建一个use函数来统一使用插件，上例使用use的写法为 YourComponent.use(FooPlugin); // global Regular.use(FooPlugin); PART2. 实例接口上一部分所讲到的都是关于原型的一些东西，现在我们来看看实例，所有的实例接口都带有$前缀，不推荐进行重写。接下来我们一个一个来研究一下这些接口。 一、$inject这个方法用于插入组件到指定的位置 component.$inject(element[, direction]) element为节点的id值(或者是false用于移除组件），direction的值可以是以下几个：[top,bottom,after,before]，看DEMO compnent.$inject( div ) || component.$inject( div, &apos;bottom&apos; ) //resulting html &lt;div id=&quot;div&quot;&gt; &lt;div class=&apos;child&apos;&gt;&lt;/div&gt; &lt;h2&gt;Example&lt;/h2&gt; &lt;/div&gt; 调用component.$inject(fasle)后即将组件从原插入位置移除（但并未销毁），后续可继续inject它。 二、$watch &amp;&amp; $unwatch用于注册监听回调： component.$watch(expression, callback(newValue, oldValue) 一旦表达式的值发生变化，回调函数就会执行。 类似于js定时器，该方法会返回一个watchid，用于$unwatch解除监听（极少使用到，除非想要实现在模板回收前清除某一绑定？？）： var id = component.$watch(&apos;b&apos;, function(){ alert(&apos;b watcher 2&apos;); }) component.$unwatch(id); 三、$update 由于regularjs是基于脏检查，所以当不是由regularjs本身控制的操作(如事件、指令)引起的数据操作，可能需要你手动的去同步data与view的数据. $update方法即帮助将你的data同步到view层. 与react不同，每次state更新以后都会触发UI的rerender，regualr并不会（准确说是并不一定）在你的data变化之后刷新你的视图，你需要你手动的去监听你要改变的数据继而实现UI更新，看DEMO： var component = new Regular({ template: &quot;&lt;h2 ref=&apos;h2&apos; on-click={title=title.toLowerCase()}&gt;{title}&lt;/h2&gt;&quot;, data: { title: &quot;REGULARJS&quot; } }); component.data.title = &quot;LEELUOLEE&quot;; //=&gt; also log &apos;REGULARJS&apos;, regularjs don&apos;t know the value is changed. console.log( component.$refs.h2.innerHTML ) // force synchronizing data and view component.$update() //=&gt; &apos;leeluolee&apos;. synchronize now. console.log( component.$refs.h2.innerHTML ) 上一DEMO中的操作等价于 component.$update(&quot;title&quot;,&quot;LEELUOLEE&quot;) $update()的一般使用方法为component.$update([expr] [, value])。由于$update()的特殊性，要求传入的表达式必须要有set方法（不过我们一般会用它来更新data变化，默认就带了set方法）。再看一个更普适的DEMO： // multiple component.$update({ &quot;user.name&quot;: &quot;leeluolee&quot;, &quot;user.age&quot;: 20 }) // is equlas to component.data.user.name = &apos;leeluolee&apos; component.data.user.age = 20 component.$update() 四、$on &amp;&amp; $emit &amp;&amp; $offRegular支持为组件绑定自定义事件，配套的还有事件的触发器、事件的解绑。看一个DEMO马上就懂了： var component = new Regular(); var clickhandler1 = function(arg1){ console.log(&apos;clickhandler1:&apos; + arg1)} var clickhandler2 = function(arg1){ console.log(&apos;clickhandler2:&apos; + arg1)} var clickhandler3 = function(arg1){ console.log(&apos;clickhandler3:&apos; + arg1)} component.$on(&apos;hello&apos;, clickhandler1); component.$on(&apos;hello&apos;, clickhandler2); component.$on({ &apos;other&apos;: clickhandler3 }); component.$emit(&apos;hello&apos;, 1); // handler1 handler2 trigger component.$off(&apos;hello&apos;, clickhandler1) // hello: handler1 removed component.$emit(&apos;hello&apos;, 2); // handler1 handler2 trigger component.$off(&apos;hello&apos;) // all hello handler removed component.$off() // all component&apos;s handler removed component.$emit(&apos;other&apos;); 实际应用的时候还可以直接在模板上绑定和触发（见Regular学习笔记）。 五、其他接口剩下的都是一些简单的接口了，列一下就行 component.$get(Expression|String) 获得一个expression的值 component.$refs 获取标记的节点 component.$mute( isMute ) 选择是否使组件失效（不参与脏检查），mute adj. 哑的,沉默的","categories":[],"tags":[{"name":"Regular","slug":"Regular","permalink":"http://ensorrow.github.io/tags/Regular/"},{"name":"NETEASE","slug":"NETEASE","permalink":"http://ensorrow.github.io/tags/NETEASE/"}],"keywords":[]},{"title":"Regular学习笔记(一)","slug":"Regular学习笔记-一","date":"2016-08-01T11:03:41.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/08/01/Regular学习笔记-一/","link":"","permalink":"http://ensorrow.github.io/2016/08/01/Regular学习笔记-一/","excerpt":"regular笔记：Regular是一个类似于react，vue的轻量框架 一. 模板语法首先要知道模板的语法类型，总共只有两种语句：功能语句&amp;插值语句 功能语句就像这样： {#list Expression as Var } ... {/list} 有开有闭，开闭符号貌似是可以自定义的。 插值语句是传统的mustache，直接{ Expression }就行了。 所有的expression在编译之后会成为一个表达式对象，使用$expression来访问它，表达式对象有两个部分：get()&amp;set() get(context) 看DEMO比较好懂 // 定义一个组件 var component = new Regular({ data: { user: &apos;leeluolee&apos;, age: 20 } }); // 通过$expression传入自定义参数创建组件的表达式对象实例 var expr = component.$expression(&quot;user + &apos;:&apos; + (age - 10)&quot;) // 调用实例的get方法，传入组件对象 alert(expr.get(component) === &quot;leeluolee:10&quot; ) //true set(context, value)","text":"regular笔记：Regular是一个类似于react，vue的轻量框架 一. 模板语法首先要知道模板的语法类型，总共只有两种语句：功能语句&amp;插值语句 功能语句就像这样： {#list Expression as Var } ... {/list} 有开有闭，开闭符号貌似是可以自定义的。 插值语句是传统的mustache，直接{ Expression }就行了。 所有的expression在编译之后会成为一个表达式对象，使用$expression来访问它，表达式对象有两个部分：get()&amp;set() get(context) 看DEMO比较好懂 // 定义一个组件 var component = new Regular({ data: { user: &apos;leeluolee&apos;, age: 20 } }); // 通过$expression传入自定义参数创建组件的表达式对象实例 var expr = component.$expression(&quot;user + &apos;:&apos; + (age - 10)&quot;) // 调用实例的get方法，传入组件对象 alert(expr.get(component) === &quot;leeluolee:10&quot; ) //true set(context, value) 同样还是看DEMO，很好理解 // component as context var component = new Regular({ data: { users: [ {name: &apos;leeluolee&apos;}, {name: &apos;luobo&apos;} ], index:0 } }); var expr = component.$expression(&apos;users[index].name&apos;) expr.set(component, &apos;daluobo&apos;); alert(component.data.users[0].name === &apos;daluobo&apos;) // true 二. 指令和vue类似，regular也有一套自己的指令系统。当rugular解析到一个属性，首先会去查是否是一个注册指令（预设or自定义），是则交由指令的link函数，否则视为普通属性。首先看看如何自定义指令。 定义指令每一个组件可以通过Component.directive来扩展指令，其中的核心为link函数 link(element, value, attrs)element为指令绑定的节点，value可以传入值或表达式，attrs指节点上的属性列表，如 Regular.directive(&apos;r-html&apos;, function(elem, value){ this.$watch(value, function(newValue){ elem.innerHTML = newValue }) }) 如果希望销毁这个函数，只需要在link函数执行末返回一个新的函数 return function(){ //新的link函数 } 内建指令（预设） r-model（数据双向绑定） r-style（行内计算样式） r-class（如判断class是否为active） r-hide（节点是否展示） r-html（类似于xss） r-animation（声明式动画） 具体使用时查阅api文档。 指令被用来代替一些常用的DOM操作，但还有一些DOM操作是指令不便于胜任的，regular使用Regular.DOM实现了一部分诸如DOM插入、DOM删除的功能 Regular.dom.inject(element, refer, direction)DOM插入操作。element指要被插入的节点，refer指参考节点，direction指组件插入的位置，有‘top’, ‘bottom’, ‘after’, or ‘before’四个参数可选。 Regular.dom.on(element, event, handle)这个方法中的event对象已被修正（兼容IE6-8），回调也被修正为element对象本身。见DEMO： var dom = Regular.dom; dom.on(element, &apos;click&apos;, function(ev){ ev.preventDefault(); }) 其他的dom操作比较简单，列一下就行了 Regular.dom.off(node, event, handle) Regular.dom.addClass(element, className) Regular.dom.delClass(element, className) Regular.dom.text(element[, value]) Regular.dom.html(element[, value]) Regular.dom.attr(element, name [ , value]) 三. 组件组件 = 模板 + 数据 + 业务逻辑，是一种独立的，可复用的交互元素的封装。 组件的定义很简单，直接看DEMO： var Component = Regular.extend( options ); var SubComponent = Component.extend( options ); var sub = new SubComponent; var component = new Component; console.log(sub instanceof Regular) // true console.log(sub instanceof Component) // true console.log(sub instanceof SubComponent) // true options对象有以下几个属性： template config init destroy name event data 其中的name是指该组件注册到父组件命名空间的名称，以便于在父组件中内嵌使用 var Component = SuperComponent.extend({ //other options name: &apos;foo1&apos; }) var Component2 = SuperComponent.extend({ template: &quot;&lt;foo1&gt;&lt;/foo1&gt;&quot; }) 也可以通过Component.component来注册 var Component = SuperComponent.extend({}); //第一个参数为注册名称，第二个为父组件 SuperComponent.component(&apos;foo1&apos;, Component) 其他的参数自行查阅API文档-静态接口-options。 组件初始化定义了一个组件之后，可以以两种方式进行初始化。比如说定义一个Pager组件： var Pager = Regular.extend({ name: &apos;pager&apos; // other options }) 进行初始化的两种方法分别如下： 1. 通过js进行初始化var pager = new Pager({ data: { current: &apos;1&apos; } }) pager.$on(&apos;nav&apos;, someCallback) 2. 直接在模板中进行初始化&lt;pager current=1 on-nav={someCallback($event)} /&gt; 在模板中的初始化实际上使用了options里的name属性，可以使用Component.component自定义，这种方法即所谓的内嵌组件。 内嵌组件内嵌组件通常会传入一些属性，这些属性会成为data的成员，如 &lt;pager total=100 current={1} show={show} &gt;&lt;/pager&gt; 则data.tatal = ‘100’, data.current = 1 &amp; pager.data.show = this.data.show (this =&gt; 模板所在组件)。若属性没有值则默认为true，属性名若有连字符则转为驼峰式，如 &lt;pager show-modal={true} isHide={hide}/&gt; 使用data.showModal访问show-modal属性。on-[eventName]自动转换为组件事件绑定： &lt;pager on-nav={this.nav($event)}&gt;&lt;/pager&gt; 相当于pager.$on(&#39;nav&#39;, this.nav.bind(this))。还有两个特殊属性ref &amp; isolate，到时候再说。 四. 事件在Regular中，事件分为两类 DOM事件 组件事件 DOM事件节点上的以on-开头的属性均会被作为DOM事件处理，如on-click={Expression}。regular在这一部分的实现原理为：如果遇到on-xx属性，首先检查是否注册自定义事件，若无，则使用addEventListener来绑定事件，所以js所有原生事件都可以得到很好的支持。自定义DOM事件（如判断键盘某个键被按下）的方法如下： Component.event(event, fn) event为自定义事件名称，fn为对应执行的函数，包含两个参数fn(elem, fire) elem: 绑定节点 fire：触发器 直接看DEMO： var dom = Regular.dom; Regular.event(&apos;enter&apos;, function(elem, fire){ function update(ev){ if(ev.which == 13){ // ENTER key ev.preventDefault(); fire(ev); // if key is enter , we fire the event; } } dom.on(elem, &quot;keypress&quot;, update); return function destroy(){ // return a destroy function dom.off(elem, &quot;keypress&quot;, update); } }); // use in template &lt;textarea on-enter={this.submit($event)}&gt;&lt;/textarea&gt;` 事件绑定可以用on-，同时也可以使用事件代理的方法，即使用delegate-代替on-，一般用于大型列表 &lt;div delegate-click=&quot;remove&quot;&gt;Delte&lt;/div&gt; //Proxy way via delegate &lt;div delegate-click={this.remove()}&gt;Delte&lt;/div&gt; // Evaluated way via delagate 事件触发时会有一个特殊的$event变量存储在data中，可以在模板中直接使用它，如： new Regular({ template: &quot;&lt;button on-click={this.add(1, $event)}&gt; count+1 &lt;/button&gt; \\ &lt;b&gt;{count}&lt;/b&gt;&quot;, data: {count:1}, add: function(count, $event){ this.data.count += count; alert($event.pageX) } }).$inject(document.body); $event对象是经过修正的，在兼容IE6前提之下可以提供使用的属性有： origin: 绑定节点 target: 触发节点 preventDefault(): 阻止默认事件 stopPropagation(): 阻止事件冒泡 which pageX pageY wheelDelta event: 原始事件对象 组件事件什么叫组件事件呢？举个例子就明白了：组件的生命周期。Regular集成了Emmiter，所有组件可以使用以下接口实现事件驱动的开发： component.$on: 用于添加事件监听器 component.$off: 用于解绑事件监听器 component.$emit: 用于触发某个事件 组件的事件绑定与DOM事件绑定很类似，只是一个是作用于组件一个作用于DOM而已，如： //??? &lt;div&gt; &lt;pager on-nav={ this.refresh($event) }&gt;&lt;/pager&gt; &lt;/div&gt; 组件的生命周期分三个阶段： $config: 会在compile之前触发，你可以在此时预处理组件数据 $init : 会在compile之后触发，此时，dom结构已经生成，你可以通过ref来获取了 $destroy: 会在组件被destroy时，触发 无论是DOM事件还是组件事件，处理事件的方法都是一致的，有两种方法： 使用表达式（推荐） 使用表达式则事件触发后表达式会被运行一次 &lt;div on-click={this.remove(index)}&gt;Delte&lt;/div&gt; remove被定义在组件当中 var Component = Regular.extend({ template:&apos;example&apos;, remove: function(index){ this.data.list.splice(index ,1); // other logic } }) 非表达式（函数名） 传入的不是表达式时，事件会被代理至组件的事件系统当中，使用$on来处理对应的事件 &lt;div on-click=&quot;remove&quot;&gt;Delte&lt;/div&gt; var Component = Regular.extend({ template:&apos;example&apos;, init: function(){ this.$on(&quot;remove&quot;, function($event){ // your logic here }) } }) 五. 过滤器与计算属性过滤器与Python中的过滤器类似如： &lt;p&gt;{ [1,2,3] | join: &quot;+&quot; } = 6&lt;/p&gt; //过滤器结果为&quot;1+2+3&quot; 过滤器一部分是预设的，自定义过滤器的方法如下： Component.filter(name, factory) 其中factory为函数对象，有get和set两个方法，直接传函数的话转换为factory.get。双向过滤器以后再看。 计算属性计算属性与vue的计算属性几乎完全一致。传入的计算属性可以是三种类型的： 包含get/set的对象 直接传入函数作为getter 传入字符串表达式作为Expression对象 一个一个看吧。首先是对象类型的计算属性： var component = regular.extend({ computed: { fullname: { //传入data属性，返回处理后的属性fullname get: function(data){ return data.first + &quot;-&quot; + data.last; }, //fullname设置器，传入希望的值及data属性，设置data.first、data.last从而get到fullname为对应值 set: function(value, data){ var tmp = value.split(&quot;-&quot;); data.first = tmp[0]; data.last = tmp[1]; } } } }) 然后是函数类型的计算属性，函数直接被作为getter函数存在，没有setter： var component = regular.extend({ computed: { fullname: function(data){ return data.first + &quot;-&quot; + data.last; } } }) 最后是字符串表达式，直接被处理为Expression对象 var component = regular.extend({ computed: { fullname: &quot;first+ &apos;-&apos; + last&quot; } }) 贴几个自己跟着写的小DEMO可以自己添加item的NoteList &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;regular.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var Note = Regular.extend({ template: &quot;&lt;input type=&apos;text&apos; r-model={draft}&gt;&quot;+ &quot;&lt;button on-click={this.post()}&gt; post &lt;/button&gt;&quot;, post: function(){ var _data = this.data; this.$emit(&apos;post&apos;, _data.draft); //post事件触发时draft作为参数$event，用到了组件事件知识点 _data.draft = &apos;&apos;; }, data: { draft: &apos;&apos; }, name: &apos;note&apos; }); var Notelist = Regular.extend({ template: //note组件的post事件触发时执行后面的表达式 &quot;&lt;note on-post={ items.push({ content: $event }) } /&gt;&quot;+ &quot;&lt;ol&gt;{#list items as item}&quot;+ &quot;&lt;li class={item.done?&apos;done&apos;:&apos;&apos;} on-click={item.done = !item.done}&gt;{ item.content }&lt;/li&gt;&quot;+ &quot;{/list}&lt;/ol&gt;&quot; }); var notelist = new Notelist({ data: { items: [ {content: &apos;game&apos;}, {content: &apos;homewok&apos;} ] } }).$inject(&apos;#app&apos;); &lt;/script&gt; 拓展 数据绑定与脏检查 基于类的数据绑定（klass，supr）","categories":[],"tags":[{"name":"Regular","slug":"Regular","permalink":"http://ensorrow.github.io/tags/Regular/"},{"name":"NETEASE","slug":"NETEASE","permalink":"http://ensorrow.github.io/tags/NETEASE/"}],"keywords":[]},{"title":"使用express处理get与post请求","slug":"使用express处理get与post请求","date":"2016-05-23T02:41:53.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/05/23/使用express处理get与post请求/","link":"","permalink":"http://ensorrow.github.io/2016/05/23/使用express处理get与post请求/","excerpt":"写网站后端的入门需求必然是处理get请求和post请求，使用express处理这两种请求都特别的简单，一眼就能看懂。 首先是get请求，get请求的参数都附在请求的url后面（即Query String），要获取一个请求然后读取它的Query就像这样： //前端 GET /test?name=lzy&amp;netid=21232 //后端,app是一个express实例 app.get(&apos;/tset&apos;, function(req, res){ console.log(req.query.name); console.log(req.query.netid); //req即request对象 }) 然后就是POST请求，post请求的请求内容在body里，需要使用bodyParser中间件（EUX项目已引入）； //前端 &lt;form action=&quot;/test&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;address&quot;&gt; &lt;/form&gt; //后端 app.post(&apos;/test&apos;, function(req, res){ console.log(req.body.username); console.log(req.body.address); //使用了bodyParser中间件 }) 当然啦，如果你请求的url后面加上Query stringform action=&quot;/test?id=xxx&quot;你也可以在req对象的query属性获取到它。 get请求除了query string的形式，还可以通过请求路径来传递信息，举个栗子： GET /test/lzy/21415 app.get(&apos;/test/:name/:netid&apos;, function(req, res){ console.log(req.params.name); console.log(req.params.netid); })","text":"写网站后端的入门需求必然是处理get请求和post请求，使用express处理这两种请求都特别的简单，一眼就能看懂。 首先是get请求，get请求的参数都附在请求的url后面（即Query String），要获取一个请求然后读取它的Query就像这样： //前端 GET /test?name=lzy&amp;netid=21232 //后端,app是一个express实例 app.get(&apos;/tset&apos;, function(req, res){ console.log(req.query.name); console.log(req.query.netid); //req即request对象 }) 然后就是POST请求，post请求的请求内容在body里，需要使用bodyParser中间件（EUX项目已引入）； //前端 &lt;form action=&quot;/test&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;address&quot;&gt; &lt;/form&gt; //后端 app.post(&apos;/test&apos;, function(req, res){ console.log(req.body.username); console.log(req.body.address); //使用了bodyParser中间件 }) 当然啦，如果你请求的url后面加上Query stringform action=&quot;/test?id=xxx&quot;你也可以在req对象的query属性获取到它。 get请求除了query string的形式，还可以通过请求路径来传递信息，举个栗子： GET /test/lzy/21415 app.get(&apos;/test/:name/:netid&apos;, function(req, res){ console.log(req.params.name); console.log(req.params.netid); }) 把http请求结合一下ajax，就是这个样子了： //前端 //ajax验证用户名是否存在 var $useridInput = $(&apos;input[name=userid]&apos;); $useridInput.change(function() { var tmpurl = &apos;/user/chkuser?userid=&apos;+$useridInput.val(); $.ajax({ url: tmpurl, success: function(data,status){ if(data.exist){ console.log(&apos;用户名存在!&apos;); } else{ console.log(&apos;用户名不存在&apos;); } }, dataType: &apos;json&apos; }); }); //后端 router.get(&apos;/chkuser&apos;, ajaxchk); function ajaxchk(req, res){ var inuser = req.query.userid; var User = mongoose.model(&apos;User&apos;); User.findOne({userid:inuser}, function(err, result){ if (err) console.log(err); console.log(result); if(result){ console.log(&apos;en&apos;) return res.json({exist: 1}); } else { return res.json({exist: 0}); } }); } 这样差不多就能做一些简单的功能啦😅","categories":[],"tags":[{"name":"Node","slug":"Node","permalink":"http://ensorrow.github.io/tags/Node/"},{"name":"Express","slug":"Express","permalink":"http://ensorrow.github.io/tags/Express/"}],"keywords":[]},{"title":"EUX PC页面开发完整流程","slug":"EUX-PC页面开发完整流程","date":"2016-05-21T09:43:31.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/05/21/EUX-PC页面开发完整流程/","link":"","permalink":"http://ensorrow.github.io/2016/05/21/EUX-PC页面开发完整流程/","excerpt":"鉴于小伙伴们开发过程无从下手，这里写一篇完整前后端开发流程的文档。在开发之前，请将完整代码clone到本地，执行npm install安装模块依赖（貌似还需要全局安装gulp和配置python环境），安好数据库，做好mongorestore，能够正常运行以后进入我们的开发流程（这些过程详见上一篇文档）。 一、前端部分开发流程目前开发集中在/static/admin这个目录下进行。admin下有这几个东西： main.js, app的路由配置信息等 build.js, webpack打包以后的app主文件（忽略它） /components, 用于存放自定义Vue组件的目录, 一般将可复用的部分抽象为组件 /containers, 用于存放页面容器（外壳）, 在容器里引用、拼凑组件 现在分析一下各目录下现有的文件，首先看一下components，里面有这些文件 common.vue，公共头部和侧边栏组件 introbox.vue，成员管理界面复用的个人信息组件 然后看一下containers app.vue，app的主入口文件 Concat.vue，员工信息容器组件 Grade.vue，绩效考评容器 Work.vue，作业考评容器 好了，现在开始我们的前端开发流程，我们的开发大概分为以下几步：","text":"鉴于小伙伴们开发过程无从下手，这里写一篇完整前后端开发流程的文档。在开发之前，请将完整代码clone到本地，执行npm install安装模块依赖（貌似还需要全局安装gulp和配置python环境），安好数据库，做好mongorestore，能够正常运行以后进入我们的开发流程（这些过程详见上一篇文档）。 一、前端部分开发流程目前开发集中在/static/admin这个目录下进行。admin下有这几个东西： main.js, app的路由配置信息等 build.js, webpack打包以后的app主文件（忽略它） /components, 用于存放自定义Vue组件的目录, 一般将可复用的部分抽象为组件 /containers, 用于存放页面容器（外壳）, 在容器里引用、拼凑组件 现在分析一下各目录下现有的文件，首先看一下components，里面有这些文件 common.vue，公共头部和侧边栏组件 introbox.vue，成员管理界面复用的个人信息组件 然后看一下containers app.vue，app的主入口文件 Concat.vue，员工信息容器组件 Grade.vue，绩效考评容器 Work.vue，作业考评容器 好了，现在开始我们的前端开发流程，我们的开发大概分为以下几步： 1.在main.js配置路由跳转信息在这里我们的几个项目已经帮你配好了，分别是/work,/grade,/concat，分析一下代码： import App from &apos;./containers/app.vue&apos; import Concat from &apos;./containers/Concat.vue&apos; import Grade from &apos;./containers/Grade.vue&apos; import Work from &apos;./containers/Work.vue&apos; router.map({ &apos;/work&apos;: { component: Work }, &apos;/grade&apos;: { component: Grade }, &apos;/concat&apos;: { component: Concat } }); 由于我们做的是SPA单页面应用，这些路由对应的组件其实都嵌套在一个最高级的父级容器里 router.redirect({ &apos;*&apos;: &apos;/work&apos; }); router.start(App, &apos;#app&apos;) 也就是说默认跳转到/work下面，最高级容器为App.vue，#app为App组件对应的挂载点（在/app/views/admin.html里） &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/admin/build.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/dist/js/admin/message.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; 如果要新建项目的话也就是自己新建一个组件，然后在router.map里加一项就行啦~ 2.使用vue写静态页面一个vue组件大概是这个样子的 &lt;template&gt; &lt;div&gt;test&lt;/div&gt; &lt;/template&gt; &lt;style&gt; div{ background-color: #fff; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; export default{ data(){ return { //该组件的数据放在这里 } }, method: { //自定义方法写在这里 } } &lt;/script&gt; 然后你在其他地方引用你的组件 import Component from &apos;../components/test.vue&apos; 在需要使用组件的地方把它注册成一个自定义标签 import Vue from &apos;vue&apos; Vue.component(&apos;my-com&apos;,Component) 在template里引用就行啦 &lt;my-com&gt;&lt;/my-com&gt; 组件里如果使用静态资源的话，把你的静态资源（如图片）放到/static/src/admin下，最好一个项目放一个目录，然后在组件里引用编译以后的资源/dist/admin即可。 这只是一个大概的流程，请抽空将vue.js文档完整过一遍 二、后端开发流程前后端通过api进行数据交互，通过controller制作api接口。在开发后端之前，确保你明白post请求和get请求大致区别😂。先看一个例子吧： router.get(&apos;/schk&apos;, selfcheck); //员工自主申请 function selfcheck(req, res) { res.render(&apos;user/selfcheck&apos;, { title: &apos;员工自主验证&apos;, user: req.session.user }) } 未完待续","categories":[],"tags":[{"name":"EUX","slug":"EUX","permalink":"http://ensorrow.github.io/tags/EUX/"},{"name":"Vue","slug":"Vue","permalink":"http://ensorrow.github.io/tags/Vue/"}],"keywords":[]},{"title":"前端性能优化：图片篇","slug":"前端性能优化：图片篇","date":"2016-05-05T14:30:19.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/05/05/前端性能优化：图片篇/","link":"","permalink":"http://ensorrow.github.io/2016/05/05/前端性能优化：图片篇/","excerpt":"前端图片优化的问题一直以来都是热门话题，从需求上来看，很多的站点往往是图片体积大于代码体积，图片请求多于代码文件请求，给前端的性能带来了很大的困扰。那么解决方案呢？🌚 一.雪碧图+图片压缩什么是雪碧图呢，雪碧图即css sprites，是一种把一堆小图片拼成一张大图的简单粗暴的技术，拼完以后前端所有要用到图片的地方使用css背景图片、通过背景定位来展示对应的图片。优势呢，就是减少了一大堆http请求，这个时候缺点就很明显了🌚，由于需要使用背景图片定位，图片大小最好得是确定的（不确定的话就用rem来算），然后还有起一大堆不同的class名来区分各个图片，逼死起名困难症🌚。 图片压缩就很简单粗暴了，无损压缩嘛，还有切图格式的问题 优先用 png 而不是 gif 压缩 png 去掉 jpg 的 metadata 压缩 gif 动画 尝试使用 png8 避免使用 AlphaImageLoader 压缩动态生成的图像 使 favicon 更小 可缓存 使用 CSS Sprites 二.base64base64是个什么东西呢？看一看用法就明白了 &lt;img src=&quot;data:imagegif;base64,AAAA&quot;&gt; //或者像这样，在css里 background-image: url(data:imagegif;base64,AAAA) 图片的编码已经在base64编码里了，浏览器解析出来那段代码就成功加载了那张图片，一般来说base6编码的大小比原图大小要稍大些，那用它的优势在哪呢🌚，还是减少http请求，性能方面的话，自己衡量一下是那点带宽影响更大还是额外请求影响更大再决定用不用吧。","text":"前端图片优化的问题一直以来都是热门话题，从需求上来看，很多的站点往往是图片体积大于代码体积，图片请求多于代码文件请求，给前端的性能带来了很大的困扰。那么解决方案呢？🌚 一.雪碧图+图片压缩什么是雪碧图呢，雪碧图即css sprites，是一种把一堆小图片拼成一张大图的简单粗暴的技术，拼完以后前端所有要用到图片的地方使用css背景图片、通过背景定位来展示对应的图片。优势呢，就是减少了一大堆http请求，这个时候缺点就很明显了🌚，由于需要使用背景图片定位，图片大小最好得是确定的（不确定的话就用rem来算），然后还有起一大堆不同的class名来区分各个图片，逼死起名困难症🌚。 图片压缩就很简单粗暴了，无损压缩嘛，还有切图格式的问题 优先用 png 而不是 gif 压缩 png 去掉 jpg 的 metadata 压缩 gif 动画 尝试使用 png8 避免使用 AlphaImageLoader 压缩动态生成的图像 使 favicon 更小 可缓存 使用 CSS Sprites 二.base64base64是个什么东西呢？看一看用法就明白了 &lt;img src=&quot;data:imagegif;base64,AAAA&quot;&gt; //或者像这样，在css里 background-image: url(data:imagegif;base64,AAAA) 图片的编码已经在base64编码里了，浏览器解析出来那段代码就成功加载了那张图片，一般来说base6编码的大小比原图大小要稍大些，那用它的优势在哪呢🌚，还是减少http请求，性能方面的话，自己衡量一下是那点带宽影响更大还是额外请求影响更大再决定用不用吧。 三.响应式图片为了得到更好的显示效果，一般我们会使用更加高清的图片然后设置max-width:100%，不可避免的图片会很大，那么如果我的设备屏幕实际上很小，那就完全没必要加载那么大的图片了，小的就可以满足清晰度要求，这个时候就要使用到响应式图片。 主要用到的其实就是srcset属性和sizes属性，看一个小的demo &lt;img src=&quot;image1.jpg&quot; srcset=&quot;image2.jpg 256w,image1.jpg 512w&quot; sizes=&quot;(min-width: 36em) 33.3vw, 100vw&quot;&gt; 其中的256w和512w作为对应图片链接的描述符，一般使用128w,256w,512w分别对应1x,2x,3x屏幕，至于后面的sizes，括号内容表示媒体查询条件，第一个为满足条件的尺寸，第二个为不满足条件尺寸。图片只在页面加载时根据屏幕像素密度和viewport宽度加载，与css响应式是不一样的。 四.延迟加载假设我的网页很长很长，图片很多很多（比如多图慎点那种），但是我可能看了一下就没兴趣了，那是不是完全没有必要加载后面的图片了，这个时候就要有一个延迟加载的思想。 图片延迟加载也称懒加载，通常应用于图片比较多的网页，如果一个页面图片比较多，且页面高度或宽度有好几屏，页面初次加载时，只显示可视区域的图片（非可视区域图片使用1*1的图片占位，图片大小css控制），当页面滚动的时候，图片进入了可视区域再进行加载（修改src），这样可以显著的提高页面的加载速度，更少的图片并发请求数也可以减轻服务器的压力。如果用户仅仅在首屏停留，还可以节省流量。具体的实现方法可以看一个插件，就叫lazeload。 五.图标字体用过bootstrap的同学肯定对方便的fontawesome图标字体印象深刻，可以无损放大缩小，可以修改颜色，只要加个类名就可以使用图标，感觉是不是很爽🌚。优势呢。。。矢量&amp;方便好用，不过图标没有一定的量可能不大需要，而且矢量图可能美工压力也比较大，我们只要知道怎么用就行啦，有的时候用现成的图标减轻一下美工同学的工作量也是极好的。可以看一下一个专门用来做图标字体的网站。 阿里UX矢量图标库–最强大的矢量图标库-Icon font制作力荐工具 六.svgsvg作为矢量图，和iconfont对比起来优势可能就是字体可能在样式修改方面受限较多，其次字体文件一般都弄的挺大的，然后兼容性差点。svg也可以认为就是图片，使用方法也很简单。 1.直接作为图片文件引入 &lt;img src=“gblogo.svg” onerror=“this.onerror=null; this.src=”gblogo.png“”&gt; //or css background:url(gblogo.svg) 2.将svg代码拷到html文件里 &lt;g class=“logo” transform=“translate（0.000000，500.000000） scale（0.100000，-0.100000）” fill=“#000000” stroke=“none”&gt; //本质上还是一个标签，可以定义样式 .logo:hover{ fill： #F08000;} 前端没啥问题，看美工愿不愿意做啦~😆","categories":[],"tags":[{"name":"EUX","slug":"EUX","permalink":"http://ensorrow.github.io/tags/EUX/"},{"name":"前端性能","slug":"前端性能","permalink":"http://ensorrow.github.io/tags/前端性能/"}],"keywords":[]},{"title":"js基础巩固（一）","slug":"js基础巩固","date":"2016-04-30T14:41:04.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/04/30/js基础巩固/","link":"","permalink":"http://ensorrow.github.io/2016/04/30/js基础巩固/","excerpt":"学习一门语言，基础是很重要的。今天花一点时间研究记录一下js那些基础、原理性的小东西。 一.原始类型和对象类型js有两种基本类型，第一类是基本（值）类型，第二类是对象（引用）类型，首先看一下基本类型 Undefined Null Number String Boolean 然后是引用类型 Date Array Regexp Function Object。。。 引用类型之所以叫引用类型是因为对象在栈内存中只保存它在堆内存中的地址","text":"学习一门语言，基础是很重要的。今天花一点时间研究记录一下js那些基础、原理性的小东西。 一.原始类型和对象类型js有两种基本类型，第一类是基本（值）类型，第二类是对象（引用）类型，首先看一下基本类型 Undefined Null Number String Boolean 然后是引用类型 Date Array Regexp Function Object。。。 引用类型之所以叫引用类型是因为对象在栈内存中只保存它在堆内存中的地址 所以这个时候就会发生下面的事情 var c = {x: 1}; var d = c; d.x = 2; console.log(c.x);//2 因为指针指向的堆内存中的值已经被修改啦~😄 提到引用先插一句，js函数传参的过程都是采用的值传递方法，传递的是参数的值而不是引用（引用类型会复制一份） 关于类型判断，一般有两种方法：typeof和instanceof，前者用来判断基本类型+function+object（除掉function以外的引用类型加上null），后者用来判断实例与原型关系。 二.隐式类型转换关于隐式类型转换，我们应用最多的场景无非就是==了，经常我们会使用&#39;&#39;==false，1==true这样方便的判断来作为if等的条件，那么这背后的原理是什么呢？ 隐式类型的转换步骤大概分为五步： 双等号前后存在NaN，则无条件返回false 双等号前后有布尔值，则将布尔值转为数字再判断 双等号前后有字符串，则分为3种情况：对象（转字符串或数字）、数字（字符串转数字）、字符串（直接比较） 双等号前后为数字与对象，对象取 valueOf() || toString() null == undefined 关于对象类型转基本类型，就是两个方法，要么valueOf先转数字，要么toString转字符串，那么作为js引擎它在隐式类型转换的时候怎么知道先调用哪一个方法呢？为了试验一下我们可以重写一下它的valueOf和toString方法： var arr = {}; arr.valueOf = function() {return &quot;1&quot;;} arr.toString = function() {return &quot;2&quot;;} console.log(arr == 1);//或者arr == &quot;1&quot; //输出为true，可以看到在这里先调用的是valueOf方法 无论你是对比字符串还是对比数字还是对比布尔值，默认都是先调用valueOf，如果valueOf返回值不是一个基本类型（值类型），那么继续调用toString，比如[9].valueOf()就是[9]这个引用类型，而不是9这个数字。 三、基本包装类型为了便于操作基本类型值，ECMAScript提供了三个特殊的引用类型：Boolean、Number和 String。这些类型是的我们能够对基本类型进行一些对对象的操作，举个栗子： var str = &apos;sample&apos;; console.log(str.substring(1,3)); 讲道理的话，作为一个基本类型str是没有方法这个东西的，但是substring在这里明摆着就是它的方法啊，怎么回事呢？这个时候基本包装类型就发挥作用啦，在调用这个方法的时候，实际上会自动有这样一步操作： var s = new String(&apos;sample&apos;); console.log(s.substring(1,3)); 所以如果你想添加基本类型的属性那是不可能的，因为当你设置属性的一瞬间它会调用包装类型然后重写下面的方法，再次获取该属性时又会重新包装一遍，所以还是没有这个属性的，方法也一样。 先写这么多了，困死了😑","categories":[],"tags":[{"name":"EUX","slug":"EUX","permalink":"http://ensorrow.github.io/tags/EUX/"},{"name":"js","slug":"js","permalink":"http://ensorrow.github.io/tags/js/"}],"keywords":[]},{"title":"jQuery入门","slug":"jQuery入门","date":"2016-03-17T15:37:48.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/03/17/jQuery入门/","link":"","permalink":"http://ensorrow.github.io/2016/03/17/jQuery入门/","excerpt":"一、什么是jQuery? jQuery: The Write Less, Do More, JavaScript Library 这是来自jQuery官网的介绍，很贴切的说明了它的功能：用更少的代码编写js脚本。jquery本身就是一个js库，它给你提供了很多人性化的api，利用这些api你可以实现所有原生js的工作。 引入jquery库：使用cdn或者直接下载库，这里以百度cdn为例 &lt;script src=&quot;http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; 二、功能一览既然说jquery可以完全实现js的所有功能，那么理论上功能是无限的，不过一切功能的实现无非以这几个功能为基础： DOM遍历和DOM操作 事件处理 动画 Ajax 前两个相信所有学习过js的童鞋都特别熟悉吧，我们平时用到的大多数功能靠这两个基础功能就可以实现啦。那么接下来让我们分别过一遍吧。 三、DOM遍历和DOM操作什么是DOM呢？DOM全称 Document Object Model（文档对象模型），HTML DOM 是： HTML 的标准对象模型 HTML 的标准编程接口 W3C 标准 说起来抽象，实际操作一下就知道了","text":"一、什么是jQuery? jQuery: The Write Less, Do More, JavaScript Library 这是来自jQuery官网的介绍，很贴切的说明了它的功能：用更少的代码编写js脚本。jquery本身就是一个js库，它给你提供了很多人性化的api，利用这些api你可以实现所有原生js的工作。 引入jquery库：使用cdn或者直接下载库，这里以百度cdn为例 &lt;script src=&quot;http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; 二、功能一览既然说jquery可以完全实现js的所有功能，那么理论上功能是无限的，不过一切功能的实现无非以这几个功能为基础： DOM遍历和DOM操作 事件处理 动画 Ajax 前两个相信所有学习过js的童鞋都特别熟悉吧，我们平时用到的大多数功能靠这两个基础功能就可以实现啦。那么接下来让我们分别过一遍吧。 三、DOM遍历和DOM操作什么是DOM呢？DOM全称 Document Object Model（文档对象模型），HTML DOM 是： HTML 的标准对象模型 HTML 的标准编程接口 W3C 标准 说起来抽象，实际操作一下就知道了 js获取DOM对象： var obj = document.getElementById(&apos;test&apos;) 很熟悉吧？用Jquery来实现就是这样 $(&apos;#test&apos;) 同时jquery还支持类选择器，后代选择器等等（几乎css支持的它都支持），如 $(&apos;#test div&apos;) || $(&apos;div#test&apos;) 就是这么强大，我们称之为jquery selector，就像css选择器一样。 DOM遍历是啥意思呢？就是指你获取了一个DOM元素以后假如你要获取它的父元素或者子元素、兄弟元素等的操作办法。在js里面分别像这样 var test = document.getElementById(&apos;test&apos;); console.log(test.childNodes); //会返回一个由文本节点和元素节点组成的Nodelist数组；父元素就是parentNode,返回单个元素 运行结果图： 说一下nodeType，放一张图就懂了 获取兄弟元素： var test = document.getElementById(&apos;test&apos;); console.log(test.nextSibling); //会返回一个文本节点 test = test.nextSibling; while(test.nodeType!=1){ test = test.nextSibling; } console.log(test); 挺麻烦的对吧？这时候Jquery就特别好理解了： var test = $(&apos;#test&apos;); test.children();//子元素节点，支持传入参数获取特定元素 test.parent();//父元素节点 test.siblings();//同级所有节点 还有很重要很重要的一点，jquery获取到的是支持jquery方法的对象，不同与普通DOM对象，可以看看区别 所以以后不要把js的方法用在jquery对象上啦。顺便提一下，DOM查找遍历是挺消耗性能的，如果有多次调用的需求就把查找结果保存在变量里，不要像这样写： $(&apos;#test&apos;).length; $(&apos;#test&apos;).hide(); $(&apos;#test&apos;).show(); 尽量这样写： var test = $(&apos;#test&apos;); test.length; test.hide(); test.show(); 四、事件处理获取到DOM元素以后要做什么呢？当然是给它绑定事件啦，在js里我们一般会这样做： var test = document.getElementById(&apos;test&apos;); test.onclick = function() { alert(&apos;get!&apos;); } //或者这样 test.addEventListener(&apos;click&apos;, function() { alert(&apos;get 2!&apos;) }, false); //addEventListener第三个参数涉及到事件流的概念，即事件的冒泡、捕获阶段 addEventListener( type, function, userCapture)默认采用的是冒泡阶段捕获事件(即第三个参数userCapture默认为false)，听起来懵逼，看一个DEMO秒懂： var oinner = document.getElementById(&apos;inner&apos;); var oouter = document.getElementById(&apos;outer&apos;); inner.addEventListener(&apos;click&apos;, function() { alert(&apos;inner&apos;); },true) outer.addEventListener(&apos;click&apos;, function() { alert(&apos;outer&apos;); },true) //结果是点击inner先alert(&apos;outer&apos;) DEMO里userCapture为true，则在事件捕获阶段执行，即你点击了inner以后，outer的点击事件先执行了。盗两张图使一下： 很好懂吧~ 言归正传，说一下jquery的事件处理，还是一如既往的简单： $(&apos;#test&apos;).click(function(){ alert(&apos;hhh&apos;); }) //绑定匿名函数 //或者稍微复杂一点的 $(&apos;#test&apos;).bind(&apos;click&apos;, function() { alert(&apos;hhhh&apos;); }) jquery支持非常非常多的事件，具体的看你们的需求然后查官方文档就行了，这里列一个简单的常用事件： focus( ) 元素获得焦点 a, input, textarea, button, select, label, map, area blur( ) 元素失去焦点 a, input, textarea, button, select, label, map, area change( ) 用户改变域的内容 input, textarea, select click( ) 鼠标点击某个对象 几乎所有元素 dblclick( ) 鼠标双击某个对象 几乎所有元素 error( ) 当加载文档或图像时发生某个错误 window, img keydown( ) 某个键盘的键被按下 几乎所有元素 keypress( ) 某个键盘的键被按下或按住 几乎所有元素 keyup( ) 某个键盘的键被松开 几乎所有元素 load( fn ) 某个页面或图像被完成加载 window, img mousedown( fn ) 某个鼠标按键被按下 几乎所有元素 mousemove( fn ) 鼠标被移动 几乎所有元素 mouseout( fn ) 鼠标从某元素移开 几乎所有元素 mouseover( fn ) 鼠标被移到某元素之上 几乎所有元素 mouseup( fn ) 某个鼠标按键被松开 几乎所有元素 resize( fn ) 窗口或框架被调整尺寸 window, iframe, frame scroll( fn ) 滚动文档的可视部分时 window select( ) 文本被选定 document, input, textarea submit( ) 提交按钮被点击 form unload( fn ) 用户退出页面 window 引用自kefan_1987的博客 五、jquery常用方法获取DOM元素、绑定事件，我们的最终目的都是进行一些实际的操作，比如说改变它的样式、修改它的内容等等，东西非常多，所以要用到的话还是要上网查一下官方文档（用久了的老司机就能都记住了），这里给出一些常用的方法： $(“p”).addClass(css中定义的样式类型); 给某个元素添加样式 $(“img”).attr({src:”test.jpg”,title:”test Image”}); 给某个元素添加属性/值，参数是map $(“img”).attr(“title”, function() { return this.src }); 给某个元素添加属性/值 $(“元素名称”).html(); 获得该元素内的内容（元素，文本等） $(“元素名称”).html(“new stuff“); 给某元素设置内容 $(“元素名称”).removeAttr(“属性名称”) 给某元素删除指定的属性以及该属性的值 $(“元素名称”).removeClass(“class”) 给某元素删除指定的样式 $(“元素名称”).text(); 获得该元素的文本 $(“元素名称”).text(value); 设置该元素的文本值为value $(“元素名称”).toggleClass(class) 当元素存在参数中的样式的时候取消,如果不存在就设置此样式 $(“input元素名称”).val(); 获取input元素的值 $(“input元素名称”).val(value); 设置input元素的值为value $(“元素名称”).after(content); 在匹配元素后面添加内容 $(“元素名称”).append(content); 将content作为元素的内容插入到该元素的后面 $(“元素名称”).appendTo(content); 在content后接元素 $(“元素名称”).before(content); 与after方法相反 $(“元素名称”).clone(布尔表达式) 当布尔表达式为真时，克隆元素（无参时，当作true处理） $(“元素名称”).empty() 将该元素的内容设置为空 $(“元素名称”).insertAfter(content); 将该元素插入到content之后 $(“元素名称”).insertBefore(content); 将该元素插入到content之前 $(“元素”).prepend(content); 将content作为该元素的一部分，放到该元素的最前面 $(“元素”).prependTo(content); 将该元素作为content的一部分，放content的最前面 $(“元素”).remove(); 删除所有的指定元素 $(“元素”).remove(“exp”); 删除所有含有exp的元素 $(“元素”).wrap(“html”); 用html来包围该元素 $(“元素”).wrap(element); 用element来包围该元素 引用自kefan_1987的博客 六、实战演练实现一个简单的计数器功能： HTML部分： &lt;span&gt;0&lt;/span&gt; &lt;button&gt;加1&lt;/button&gt; js部分 &lt;script src=&quot;./jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function (){ var ospan = $(&apos;span&apos;); var obutton = $(&apos;button&apos;); obutton.click(function (){ var tmp = ospan.text(); tmp = parseInt(tmp); tmp+=1; ospan.text(tmp); }); }) &lt;/script&gt; 怎么样，有没有感觉到jquery很棒！👀","categories":[],"tags":[{"name":"eeyes","slug":"eeyes","permalink":"http://ensorrow.github.io/tags/eeyes/"},{"name":"jquery","slug":"jquery","permalink":"http://ensorrow.github.io/tags/jquery/"}],"keywords":[]},{"title":"前端基础研究","slug":"前端基础研究","date":"2016-03-11T11:54:56.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/03/11/前端基础研究/","link":"","permalink":"http://ensorrow.github.io/2016/03/11/前端基础研究/","excerpt":"基础分类： HTML基础 CSS基础 Js基础 每一项的细分下来大概是这个样子 HTML+CSS1、盒子模型，块级元素和行内元素特性与区别。2、行内块的使用，兼容性解决。3、清除浮动的方式以及各自的优劣。4、文档流的概念、定位的理解以及z-index计算规则&amp;浏览器差异性。5、CSS选择器以及优先级计算。6、常用的CSS hack。7、遇到的兼容性问题与解决方法。8、垂直水平居中的实现方式。9、常用布局的实现（两列布局、三列适应布局，两列等高适应布局等）。Javascript1、犀牛书封面的犀牛属于神马品种？（蛋逼活跃气氛用。。。犀牛书指js权威指南）2、常用的浏览器内核。3、常用的DOM操作，新建、添加、删除、移动、查找等。4、String于Array常用方法。5、设备与平台监测。6、DOM的默认事件、事件模型、事件委托、阻止默认事件、冒泡事件的方式等。7、jQuery的bind、live、on、delegate的区别（考察点与上一条重叠，切入点不同）。8、JS变量提升、匿名函数、原型继承、作用域、闭包机制等。9、对HTTP协议的理解。10、Ajax的常用操作，JS跨域的实现原理。作者：MicroMao链接：http://www.zhihu.com/question/19568008/answer/23317398来源：知乎","text":"基础分类： HTML基础 CSS基础 Js基础 每一项的细分下来大概是这个样子 HTML+CSS1、盒子模型，块级元素和行内元素特性与区别。2、行内块的使用，兼容性解决。3、清除浮动的方式以及各自的优劣。4、文档流的概念、定位的理解以及z-index计算规则&amp;浏览器差异性。5、CSS选择器以及优先级计算。6、常用的CSS hack。7、遇到的兼容性问题与解决方法。8、垂直水平居中的实现方式。9、常用布局的实现（两列布局、三列适应布局，两列等高适应布局等）。Javascript1、犀牛书封面的犀牛属于神马品种？（蛋逼活跃气氛用。。。犀牛书指js权威指南）2、常用的浏览器内核。3、常用的DOM操作，新建、添加、删除、移动、查找等。4、String于Array常用方法。5、设备与平台监测。6、DOM的默认事件、事件模型、事件委托、阻止默认事件、冒泡事件的方式等。7、jQuery的bind、live、on、delegate的区别（考察点与上一条重叠，切入点不同）。8、JS变量提升、匿名函数、原型继承、作用域、闭包机制等。9、对HTTP协议的理解。10、Ajax的常用操作，JS跨域的实现原理。作者：MicroMao链接：http://www.zhihu.com/question/19568008/answer/23317398来源：知乎 自己补充一些其他细节： 前端性能（如延迟加载） 本地存储（LocalStorage的设计目的） 东西很杂，一项一项来。 HTML&amp;CSS部分一、行内块的使用涉及的知识点：HTML规范与浏览器解析的问题 &lt;span style=&quot;background: red;&quot;&gt; haha &lt;h1 style=&quot;background: #ccc;&quot;&gt;hdjs&lt;/h1&gt; 哈哈哈 &lt;/span&gt; 二、清除浮动的方式典型应用场景： &lt;div id=&quot;outer&quot;&gt; &lt;div id=&quot;inner&quot;&gt; &lt;h2&gt;A Column&lt;/h2&gt; &lt;/div&gt; &lt;h1&gt;Main Content&lt;/h1&gt; &lt;p&gt;Lorem ipsum&lt;/p&gt; &lt;/div&gt; 如果给inner加一个浮动的话，由于它脱离了文档流会使outer容器塌陷（如果容器是由该浮动元素撑起来的话），为了实现我们想要的效果，就需要清除浮动，典型的几种方法 在outer最后加一个空的块级元素&lt;div style=&#39;clear:both&#39;&gt;&lt;/div&gt;（或者使用伪类） 给outer添加overflow: auto 解释一下2的方法，使用overflow以后会触发BFC（Block Formatting Context），BFC要求其内部元素无法影响其外部元素，为了做到这一点BFC计算高度时必须将float元素也计算在内 三、文档流和文本流的概念所谓文档流，就是说按照文档的顺序从上到下，从左到右排列元素。脱离文档流呢，就是说将某个元素从文档流抽离出来，按照另一个规则进行摆放（position:absolute||fixed，float应该是没有脱离文档流的）。 说到文档流自然就要提到z-index了，只有加了position属性的元素使用z-index才能生效（事实上除了float之外只有position这有z-index的应用场景了吧）。z-index的使用要注意的一个使用场景是： 定位元素A（z-index:100）里面有定位元素A1（z-index:300），而定位元素B和元素A兄弟关系（z-index:200）。你会发现无论A1的z-index是多大，也会被z-index是200的B所覆盖，因为A的z-index只有100。 解释为在相同的stacking context下才会用z-index来决定先后，不同时则由stacking context的z-index来决定（A和B均为stacing context）。 至于文本流呢。。。反正它和布局没有关系就对了，是计算机基础的概念吧。 四、浏览器差异浏览器内核即浏览器的渲染引擎（排版引擎），大概可以分为以下几种： Trident（又称IE内核） Gecko（Firefox内核） Webkit（Safari内核,Chrome内核Chormium原型,开源） Blink（Chrome &amp; Opera开发） 除了渲染引擎还有JavaScript引擎，如经常听的Chrome的V8引擎。 那么浏览器的兼容性问题一般都处在渲染引擎上，举个最简单的例子，在不同的浏览器上，各种元素自带的margin、padding必然不尽相同，所以往往我们都要在CSS开始加上这一段： *{ margin: 0; padding: 0; } 其他的问题诸如IE6的双倍mairgin问题，img标签的默认间距问题（float解决）等等，解决方法一般是采用CSS hack，如IE6可以认识_height、height，IE7可以认识 height等。不过随着时代发展越来越少关心这些问题啦。 五、选择器的优先级计算按照优先级顺序从高到低排列： 标签内样式（严格说不算选择器），1000 ID选择器，100 Class选择器，10 元素名选择器，1 使用后代选择器累加，与选择器相乘即可。 六、常用布局的实现方法水平居中的实现： text-align:center（行内元素） margin:0 auto position: relative||absolute &amp;&amp; left: 50% &amp;&amp; margin-left: 0.5*width||transform: translateY(-50%) justify-content: center 垂直居中的实现 height = line-height align-items: center paddingTop = paddingBottom position 常用的两栏布局定宽+自适应 float+margin-left float+overflow(BFC) flex js部分一、常用的String和Array操作String操作 获取类方法 charAt(index)，返回对应位置的字符 查找类方法 indexOf(searchValue, fromIndex)，从fromIndex处开始查找searchValue，返回对应的index lastIndexOf(seaarchValue, fromIndex) search(substr || regexp)，返回匹配字符串的起始位置或-1（如果不存在） match(substr || regexp)，若传入substr，则返回一个数组如[“b”, index: 3, input: “1a2b3c4d5e”]；传入正则则返回所有符合要求的字符串如[“1”, “2”]。 截取类方法 substring(start, end)，返回截取的字符串 slice(start, end)，参数可以为负值（即从倒数几位截取） substr(start, length) 其他类型方法 replace(regexp || substr, replacement)，将匹配的字符串替换成想要的字符串 split(seperator, howmany)，将字符串按照设置的seperator进行切割，返回最大长度为Howmany参数的数组 toLowerCase &amp;&amp; toUpperCase Array操作 shift()，删除数组的第一项，返回删除值 pop()，删除数组的最后一项，返回删除值 unshift(arg1, arg2 …)，将参数添加到数组开头，返回新数组长度 push(arg1, arg2 …)，将参数添加到数组末尾，返回新数组长度 concat(arg1, arg2 …)，复制原数组，将参数添加到新数组末尾且不修改原数组，返回新数组 splice(start, deleteCount, var1, var2 …)，从start位置开始删除deleteCount项，并从该位置起插入val1,val2,… reverse()，将数组反序 sort()，将数组按照字符编码排序（一般数字为从小到大） slice(satrt, end)，与字符串操作相同 join(separator)，将数组用separator连接成字符串 二、浏览器判断js通过userAgent来判断浏览器类型，看一个DEMO应该很好理解 var sUserAgent = navigator.userAgent.toLowerCase(); var isIpad = sUserAgent.match(/ipad/i) == &apos;ipad&apos;; var isUc = sUserAgent.match(/ucweb/i) == &apos;ucweb&apos;; if( isIpad ){ window.localtion.href = &quot;link1&quot; } else { window.localtion.href = &apos;link2&apos; } 三、call,apply&amp;bind call，第一个参数为要修改的上下文对象（this），后面为调用的函数自己的参数 apply，与call类似，但函数自己的参数放在一个数组里 bind，返回一个改变了上下文的函数，之后链式调用 看一个DEMO就明白了 var name = &apos;global&apos;; var person = { name: &apos;zero&apos; }; // 输出姓名、年龄和职业 function printInfo(age, job) { console.log(this.name, age, job); } // 直接调用 printInfo(20, &apos;前端工程师&apos;); // 打印：global 20 前端工程师 // 因为默认的上下文是window，所以this.name是全局定义的global，如果我们想打印出来zero的话，就需要改变函数执行的上下文 printInfo.call(person, 20, &apos;前端工程师&apos;); printInfo.apply(person, [20, &apos;前端工程师&apos;]); // 这两种方式是一样的，第一个参数都是传进去的上下文，this.name取的是person.name，所以打印出来的名字就是zero了，后面的为age和job，只是参数传递的方式不一样，apply比较特殊，把要传的参数放在数组里面 // 而bind和以上两种有区别，bind是es5定义的新方法，用来返回一个有自己上下文的函数，用法也比较类似： printInfo.bind(person)(20, &apos;前端工程师&apos;); // printInfo.bind(person)这一块是返回的以peron为上下文的函数，后面的(20, &apos;前端工程师&apos;)是函数调用 引用自百度知道 四、前端本地存储需要了解的就是历史悠久的cookie和新的HTML5本地存储特性了。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://ensorrow.github.io/tags/前端/"}],"keywords":[]},{"title":"EUX开发环境配置","slug":"EUX开发环境配置","date":"2016-03-10T13:12:17.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/03/10/EUX开发环境配置/","link":"","permalink":"http://ensorrow.github.io/2016/03/10/EUX开发环境配置/","excerpt":"准备工作：Node环境（搜索node.js安装即可） &amp; git环境 &amp; cnpm（自行百度安装） 一、安装配置mongoDBMAC下可以使用Homebrew直接安装（200多m，慢的一比），Windows下貌似也可以直接安装exe。安装完以后自行在根目录（怎么方便怎么建，注意windows下尽量放C盘避免权限问题）下建一个data文件夹，终端运行 mongod --dbpath /*data文件夹路径*/ 然后就会在data文件夹里自动创建好相关的文件并启动数据库，此时打开另一个终端窗口，cd到clone下来的EUX目录下，运行 mongorestore ./mongobak 数据库就配置完毕了。推荐安装Robomongo来可视化的管理数据库（不然太抽象了😂），貌似Windows，Linux，Mac都有。使用可视化管理工具的方法也很简单，先保证终端的数据库在运行，然后新建一个connect到对应端口就行啦。 二、安装node依赖首先终端cd到eux目录，然后直接运行cnpm install。不出意外的话就能安装好，但是一般意外比较多，大概有以下几种错误： node-gyp错误：如果提示找不到命令的话就全局安装它cnpm install node-gyp -g.其他编译错误首先到npm官网搜索node-gyp这个包看看它的文档，一般来说可能是电脑上缺少python环境，具体的自己查一下文档 （TODO) 然后全局安装gulp，打开终端运行 cnpm install gulp -g 再进入eux目录执行gulp，正常的话再次运行gulp就编译过啦，然后打开localhost:3000就可以看到运行结果了，就是我们酷酷的EUX首页了。","text":"准备工作：Node环境（搜索node.js安装即可） &amp; git环境 &amp; cnpm（自行百度安装） 一、安装配置mongoDBMAC下可以使用Homebrew直接安装（200多m，慢的一比），Windows下貌似也可以直接安装exe。安装完以后自行在根目录（怎么方便怎么建，注意windows下尽量放C盘避免权限问题）下建一个data文件夹，终端运行 mongod --dbpath /*data文件夹路径*/ 然后就会在data文件夹里自动创建好相关的文件并启动数据库，此时打开另一个终端窗口，cd到clone下来的EUX目录下，运行 mongorestore ./mongobak 数据库就配置完毕了。推荐安装Robomongo来可视化的管理数据库（不然太抽象了😂），貌似Windows，Linux，Mac都有。使用可视化管理工具的方法也很简单，先保证终端的数据库在运行，然后新建一个connect到对应端口就行啦。 二、安装node依赖首先终端cd到eux目录，然后直接运行cnpm install。不出意外的话就能安装好，但是一般意外比较多，大概有以下几种错误： node-gyp错误：如果提示找不到命令的话就全局安装它cnpm install node-gyp -g.其他编译错误首先到npm官网搜索node-gyp这个包看看它的文档，一般来说可能是电脑上缺少python环境，具体的自己查一下文档 （TODO) 然后全局安装gulp，打开终端运行 cnpm install gulp -g 再进入eux目录执行gulp，正常的话再次运行gulp就编译过啦，然后打开localhost:3000就可以看到运行结果了，就是我们酷酷的EUX首页了。 三、新建个人项目（如果有需要）请在dev分支上进行开发！ 1.新建项目目录，路径为app/views（最好在目录下有一个index.html）2.添加路由信息，路径为config/routers，实际导出一个js数组对象，like this module.exports = [ { &apos;url&apos;: &apos;/test&apos;, &apos;cpath&apos;: &apos;test.controller.js&apos;} ] 3.添加对应的controller，路径为app/controllers，内容像这样 var express = require(&apos;express&apos;); var router = express.Router(); router.get(&apos;/&apos;, test); function test(req, res, next) { res.render(&apos;test/index&apos;, { title: &apos;EUX测试&apos;, user: req.session.user }); } module.exports = router; 这样就可以在你自己的项目目录下进行开发了，以test为例，浏览器地址就是localhost:3000/test。 四、push到coding上这步没啥好说的，git push就完了（本地测试得通过啊，而且先git pull保证和最新dev分支没有冲突），推送完以后手动@我（QQ或微信😂），然后让我来帮你merge到master上然后部署到服务器上就行啦~ 五、关于使用到的技术电脑端页面（推荐学习路线：Vue =&gt; Express =&gt; Bootstrap) Vue.js，数据驱动的组件，为现代化的 Web 界面而生，web开发框架 Bootstrap，简洁、直观、强悍的前端开发框架，UI框架 Express - 基于 Node.js 平台的 web 应用开发框架，后端框架 mongo，非关系型数据库 微信企业号 Koa (koajs) – 基于 Node.js 平台的下一代 web 开发框架 先学这个，其他的再说","categories":[],"tags":[{"name":"EUX","slug":"EUX","permalink":"http://ensorrow.github.io/tags/EUX/"}],"keywords":[]},{"title":"开始使用Redux(二)","slug":"开始使用Redux-二","date":"2016-02-24T13:54:04.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/02/24/开始使用Redux-二/","link":"","permalink":"http://ensorrow.github.io/2016/02/24/开始使用Redux-二/","excerpt":"上一篇文章分析了一下Redux各个部分的定义、功能，今天我们就要考虑一下怎么在实际项目中使用这个state管理框架了 在应用中，只有最顶层组件是对 Redux 可知（例如路由处理）这是很好的。所有它们的子组件都应该是“笨拙”的，并且是通过 props 获取数据。 这个做法与我们现在的做法是一致的，但是按照我们一般的props传递方法，当这个组件嵌套的比较深的时候，可能就会发现要把这个数据传进去出奇的麻烦，所以很自然的我们就需要一个全局的对象，在任何嵌套的组件访问这个对象，就可以获取任何你所想要的属于全局的数据。Redux所提供的store就是充当了这一角色,现在来看看store在App中是怎么生效的。 一、根组件绑定Redux以及通过props传递怎么绑定在上一篇文章中已经提过了，绑定完了以后根组件的state以后就充当着全局的store了。首先，通过Provider把store通过props传下去： &lt;Provider store={store}&gt; {() =&gt; &lt;BaseApp /&gt;} &lt;/Provider&gt; BaseApp里通过路由再把state和action传下去： renderScene(route, navigator) { let Component = route.component; const { state, dispatch } = this.props; const action = bindActionCreators(actions, dispatch); return ( &lt;Component state={state} actions={action} {...route.params} navigator={navigator} /&gt; ); }","text":"上一篇文章分析了一下Redux各个部分的定义、功能，今天我们就要考虑一下怎么在实际项目中使用这个state管理框架了 在应用中，只有最顶层组件是对 Redux 可知（例如路由处理）这是很好的。所有它们的子组件都应该是“笨拙”的，并且是通过 props 获取数据。 这个做法与我们现在的做法是一致的，但是按照我们一般的props传递方法，当这个组件嵌套的比较深的时候，可能就会发现要把这个数据传进去出奇的麻烦，所以很自然的我们就需要一个全局的对象，在任何嵌套的组件访问这个对象，就可以获取任何你所想要的属于全局的数据。Redux所提供的store就是充当了这一角色,现在来看看store在App中是怎么生效的。 一、根组件绑定Redux以及通过props传递怎么绑定在上一篇文章中已经提过了，绑定完了以后根组件的state以后就充当着全局的store了。首先，通过Provider把store通过props传下去： &lt;Provider store={store}&gt; {() =&gt; &lt;BaseApp /&gt;} &lt;/Provider&gt; BaseApp里通过路由再把state和action传下去： renderScene(route, navigator) { let Component = route.component; const { state, dispatch } = this.props; const action = bindActionCreators(actions, dispatch); return ( &lt;Component state={state} actions={action} {...route.params} navigator={navigator} /&gt; ); } 这里用到了binActionCreators(),关于这个函数可以参考一下官方说明： 惟一使用 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，而且不希望把 Redux store 或 dispatch 传给它。 二、子组件调用回调函数首先要获取回调函数，也就是action，通过props获取：const { appendTodo } = this.props.actions;获取完以后再执行：appendTodo(text);这个时候绑定了Redux的根组件就会调用对应的回调函数（通过Reducer）： case &apos;APPEND_TODO&apos;: { var todos = [ ...state.todos ]; todos.unshift(action.todo); dataSource = state.dataSource.cloneWithRows(todos); return { ...state, ...action, todos, dataSource } } 这里return的就是新的state（不要觉得只有第一个…state才是😂），然后Redux应该会有一个机制使得传递到当前组件的props同步更新，触发UI更新（有待实践）。 未完待续，在实践中再发现哪些还需要分析","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://ensorrow.github.io/tags/React-Native/"},{"name":"Redux","slug":"Redux","permalink":"http://ensorrow.github.io/tags/Redux/"}],"keywords":[]},{"title":"开始使用Redux(一)","slug":"开始使用Redux-一","date":"2016-02-22T12:08:13.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/02/22/开始使用Redux-一/","link":"","permalink":"http://ensorrow.github.io/2016/02/22/开始使用Redux-一/","excerpt":"第一次接触这种涉及到产品架构的框架，整体的理解难度简直爆表，今天来根据RN中文网的这一篇帖子用RN( ListView + Navigator ) + Redux来开发一个ToDoList 来分析一下如何在一个RN应用中使用Redux框架。 首先将action,reducer,store这些概念再过一遍（引用来自Redux 中文文档的解释）： 1. Action Action 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。 也就是说action是传到store的唯一参数，只有给store dispatch了一个action，才能改变store；一般来说action是用来描述操作的js普通对象，像这样： { type: COMPLETE_TODO, index: 5 } 2. ReducerAction用来描述事情发生的这一事实，然后需要通过Reducer来指明需要如何来改变state，Reducer所做的事情就像这样 (previousState, action) =&gt; newState 这个直接看DEMO就行了","text":"第一次接触这种涉及到产品架构的框架，整体的理解难度简直爆表，今天来根据RN中文网的这一篇帖子用RN( ListView + Navigator ) + Redux来开发一个ToDoList 来分析一下如何在一个RN应用中使用Redux框架。 首先将action,reducer,store这些概念再过一遍（引用来自Redux 中文文档的解释）： 1. Action Action 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。 也就是说action是传到store的唯一参数，只有给store dispatch了一个action，才能改变store；一般来说action是用来描述操作的js普通对象，像这样： { type: COMPLETE_TODO, index: 5 } 2. ReducerAction用来描述事情发生的这一事实，然后需要通过Reducer来指明需要如何来改变state，Reducer所做的事情就像这样 (previousState, action) =&gt; newState 这个直接看DEMO就行了 module.exports = function(state, action) { state = state || { type: &apos;INITIAL_TODOS&apos;, todos: [] } switch(action.type) { case &apos;LOAD_TODOS&apos;: { ... } case &apos;APPEND_TODO&apos;: { var todos = [ ...state.todos ]; todos.unshift(action.todo); dataSource = state.dataSource.cloneWithRows(todos); return { ...state, ...action, todos, dataSource } } case &apos;SELECT_TODO&apos;: { ... } } return { ...state } } 用一个switch…case来判断action.type，返回对应的新state以及依应用而变的参数。 3. StoreStore是用来将action和reducer联系起来的一个由框架提供的特殊对象，store负责这些事情 维持应用的state 提供getState()方法获取state 通供dispatch(action)方法更新state 通过subscribe(listener)注册监听器 那么如何根据现有的action和reducer创建对应的store呢? import { createStore } from &apos;redux&apos; import reducer from &apos;./reducers&apos; let store = createStore(reducer) 如果要用到异步的话（肯定会用到的），就用一个redux-thunk框架 const createStoreWithThunk = applyMiddleware(thunk)(createStore); const reducer = combineReducers(reducers); const store = createStoreWithThunk(reducer); 这样就创建好store了。但是还不够，因为redux不是特地为React开发的，要想在RN上用还得用到React绑定库react-redux 注意：由于不知名的原因（本文开头链接里有），react-redux版本不能超过3.x，否则会报错 unable to resolve modules form react-redux/native，在这里我们用到的是3.0.1版，请修改package.json自行安装。 安装好以后做这几件事情： 1. 从绑定库中引入你想要用的模块（废话）我们要用到connect模块 import { connect } from &apos;react-redux/native&apos;; 2. 链接store与应用主入口这里操作可能有点难理解，但是大概是这三步 第一步，新建一个函数，该函数返回参数作为state，具体作用是把上一个App入口传入的store里的state取到并返回 function selector(state) { return { state: state } } 第二步，做一个connect链接主应用文件与取到的state，具体作用是将取到的state作为BaseApp的props来传递 export default connect(selector)(BaseApp); 第三步，利用Provider把主应用文件包装起来，把store作为props传进去 &lt;Provider store={store}&gt; {() =&gt; &lt;BaseApp /&gt;} &lt;/Provider&gt; 这样的话准备工作就算做完啦~ 好了，做完了准备工作，那么现在要干什么呢？当然是获取state，修改state啦。 具体操作还是下回分解吧，我困了👀","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://ensorrow.github.io/tags/React-Native/"},{"name":"Redux","slug":"Redux","permalink":"http://ensorrow.github.io/tags/Redux/"}],"keywords":[]},{"title":"Ajax学习笔记","slug":"Ajax学习笔记","date":"2016-02-20T09:05:47.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/02/20/Ajax学习笔记/","link":"","permalink":"http://ensorrow.github.io/2016/02/20/Ajax学习笔记/","excerpt":"我想跟后台打交道的东西是很多前端程序猿的软肋，至少我看到的好多都是这个样子的。之前对表单数据交互，Ajax，Promise一直是一知半解，那么趁着刚开学的这一段时间来补充一下这方面的知识。 一、post请求和get请求的区别首先看看百度怎么说的 GET使用URL或Cookie传参。而POST将数据放在BODY中。 GET的URL会有长度上的限制，则POST的数据则可以非常大。 POST比GET安全，因为数据在地址栏上不可见。 作为一个前端，能够经常接触到这个的大概就在form里。一个标准的from标签如下： &lt;form action=&quot;#&quot; method=&quot;get&quot;&gt;&lt;/form&gt; || &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;&lt;/form&gt; 这两者方法有什么区别呢？看看来自W3C的解释： post方法：如果采用 POST 方法，浏览器将会按照下面两步来发送数据。首先，浏览器将与 action 属性中指定的表单处理服务器建立联系，一旦建立连接之后，浏览器就会按分段传输的方法将数据发送给服务器。在服务器端，一旦 POST 样式的应用程序开始执行时，就应该从一个标志位置读取参数，而一旦读到参数，在应用程序能够使用这些表单值以前，必须对这些参数进行解码。用户特定的服务器会明确指定应用程序应该如何接受这些参数。 get方法浏览器会与表单处理服务器建立连接，然后直接在一个传输步骤中发送所有的表单数据：浏览器会将数据直接附在表单的 action URL 之后。这两者之间用问号进行分隔。 了解到这个地步就差不多啦","text":"我想跟后台打交道的东西是很多前端程序猿的软肋，至少我看到的好多都是这个样子的。之前对表单数据交互，Ajax，Promise一直是一知半解，那么趁着刚开学的这一段时间来补充一下这方面的知识。 一、post请求和get请求的区别首先看看百度怎么说的 GET使用URL或Cookie传参。而POST将数据放在BODY中。 GET的URL会有长度上的限制，则POST的数据则可以非常大。 POST比GET安全，因为数据在地址栏上不可见。 作为一个前端，能够经常接触到这个的大概就在form里。一个标准的from标签如下： &lt;form action=&quot;#&quot; method=&quot;get&quot;&gt;&lt;/form&gt; || &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;&lt;/form&gt; 这两者方法有什么区别呢？看看来自W3C的解释： post方法：如果采用 POST 方法，浏览器将会按照下面两步来发送数据。首先，浏览器将与 action 属性中指定的表单处理服务器建立联系，一旦建立连接之后，浏览器就会按分段传输的方法将数据发送给服务器。在服务器端，一旦 POST 样式的应用程序开始执行时，就应该从一个标志位置读取参数，而一旦读到参数，在应用程序能够使用这些表单值以前，必须对这些参数进行解码。用户特定的服务器会明确指定应用程序应该如何接受这些参数。 get方法浏览器会与表单处理服务器建立连接，然后直接在一个传输步骤中发送所有的表单数据：浏览器会将数据直接附在表单的 action URL 之后。这两者之间用问号进行分隔。 了解到这个地步就差不多啦 二、jQuery Ajax使用在AJAX出现之前，貌似所有的HTTP请求都是同步的，意味着你填一个表单，必须点一下提交，然后收到反馈（类似于单线程计算机？）。那么AJAX就可以让我们通过发送异步请求来及时获得反馈，更加的高效和人性化。 Api采用的是图灵机器人的api，机器人接入，访问这个api后，以问好为例，会直接返回json格式的数据 { &quot;code&quot;: 100000, &quot;text&quot;: &quot;你也好 嘻嘻&quot; } 而且没有跨域的问题（不晓得怎么实现的😂），代码如下，很简单 $(document).ready(function(){ var TURING = &apos;http://www.tuling123.com/openapi/api?key=YOUR_OWN_KEY&amp;info=你好&amp;userid=12345678&apos;; $.ajax({ type: &apos;get&apos;, url: TURING, dataType: &apos;json&apos;, //dataType应该默认就是json，在这里可有可无 beforeSend: function(xhr) { //showloading }, success: function(data, textStatus) { console.log(data.text); }, complete: function(xhr, textStatus) { //hideLoading }, error: function() { alert(&apos;error loading &apos;); } }); }); 就会在控制台输出机器人给你打招呼的信息啦。 Ajax跨域问题提到跨域问题，首先就要提到同源策略 同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。当一个浏览器的两个tab页中分别打开来 百度和谷歌的页面当一个百度浏览器执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。 所以当你用Ajax请求某一个不同源（跨域）的API时，浏览器会拒绝运行你的脚本，所以你就抓取不到想要的数据了。那么如何解决这个问题呢？ 我们都知道在我们使用script标签引入外部js时，就算不同源也是没有问题的（比如CDN?)，这是因为script标签并不被同源策略所束缚，可以获取任何服务器的脚步并执行。根据这个原理，就出现了一种叫做JSONP的东西，英文名为JSON With Padding，它是怎么实现的呢？ 简单的概括就是说，通过服务器上的操作，使得script请求完以后，将你所请求的数据传入你自定义方法名的方法中完成回调。可以看一个DEMO： &lt;script type=&quot;text/javascript&quot;&gt; //添加&lt;script&gt;标签的方法 function addScriptTag(src){ var script = document.createElement(&apos;script&apos;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script); } window.onload = function(){ //搜索apple，将自定义的回调函数名result传入callback参数中 addScriptTag(&quot;http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;q=apple&amp;callback=result&quot;); } //自定义的回调函数result function result(data) { //我们就简单的获取apple搜索结果的第一条记录中url数据 alert(data.responseData.results[0].unescapedUrl); } &lt;/script&gt; 那么在jQuery Ajax中已经帮你把jsonp直接封装好了，直接把dataType改成jsonp，jQuery会自动把数据传入你默认的callback中（也就是success方法吧？），当然，你还可以自定义jsonpCallback。找到了一个支持jsonp的api，写一个DEMO测试一下： $(document).ready(function(){ var POSTCODE = &apos;http://www.geonames.org/postalCodeLookupJSON?postalcode=10504&amp;country=US&amp;callback=?&apos;; $.ajax({ type: &apos;get&apos;, url: POSTCODE, dataType: &apos;jsonp&apos;, beforeSend: function(xhr) { //showloading }, success: function(data, textStatus) { console.log(data.postalcodes[0].adminCode2); }, complete: function(xhr, textStatus) { //hideLoading }, error: function(err) { alert(&apos;error loading &apos;+&apos;err&apos;); } }); }); 正如我们想的那样，这个请求的结果是把api对应的数据传入success方法中进行执行。然后直接在浏览器中请求这个api（在地址栏里输入）得到的是这样的： ?({&quot;postalcodes&quot;:[{&quot;adminCode2&quot;:&quot;119&quot;,&quot;adminCode1&quot;:&quot;NY&quot;,&quot;adminName2&quot;:&quot;Westchester&quot;,&quot;lng&quot;:-73.700942,&quot;countryCode&quot;:&quot;US&quot;,&quot;postalcode&quot;:&quot;10504&quot;,&quot;adminName1&quot;:&quot;New York&quot;,&quot;placeName&quot;:&quot;Armonk&quot;,&quot;lat&quot;:41.136002}]}); 也就是说callback的方法名是？（jquery会智能分配到success,如果没有自定义的话），然后这个方法里面的参数就是我们要的数据啦~😀 关于Promise的过两天再更新吧~","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://ensorrow.github.io/tags/jQuery/"},{"name":"Ajax","slug":"Ajax","permalink":"http://ensorrow.github.io/tags/Ajax/"}],"keywords":[]},{"title":"黑苹果安装记录","slug":"黑苹果安装记录","date":"2016-02-04T10:10:29.000Z","updated":"2016-11-21T06:14:10.000Z","comments":true,"path":"2016/02/04/黑苹果安装记录/","link":"","permalink":"http://ensorrow.github.io/2016/02/04/黑苹果安装记录/","excerpt":"上次装Ubuntu不小心手贱把硬盘给格了，我珍藏的那么多电影还有各种资料都不见了，重装windows和ubuntu都不是啥问题，黑苹果就不好装了，浪费了我好多天的时间，真是气死爸爸了，在这里记录一下安装过程，省的以后又去远景爬帖，心累，而且是累成狗那种累。 一、所需文件 原版10.10.3镜像，http://pan.baidu.com/s/1kUwBh8j clover原始版，http://pan.baidu.com/s/1pKeSbMj Transmac.exe，http://pan.baidu.com/s/1i4o7EfV 二、安装 使用Transmac将原版镜像写入U盘 解压clover至U盘EFI分区 安装完成 三、驱动安装完成后USB3.0、触摸板默认驱动，kext文件夹放入了VoodooPS2Controller.kext所以键鼠驱动正常（该clover开启了InjectKext:detect，在sle下没有FakeSMC.kext的情况下是会注入Clover里的驱动的，后面会把它改成Yes来默认注入）。需要驱动的设备有 显卡HD4600，独显无解 声卡（使用万能声卡） 有线网卡RTL8111 无线网卡无解，使用小度wifi替代（USB无线网卡） 那么首先使用集成工具Hackintosh Vietnam Tool.dmg http://yun.baidu.com/s/1o708FLw来安装万能声卡和有线网卡（安装时自主勾选所需驱动），顺便可以把kext wizard或者kext unity（不推荐）也装一下，还有MaciASL和IORegistryExplorer也可以装一下，后面会用到。","text":"上次装Ubuntu不小心手贱把硬盘给格了，我珍藏的那么多电影还有各种资料都不见了，重装windows和ubuntu都不是啥问题，黑苹果就不好装了，浪费了我好多天的时间，真是气死爸爸了，在这里记录一下安装过程，省的以后又去远景爬帖，心累，而且是累成狗那种累。 一、所需文件 原版10.10.3镜像，http://pan.baidu.com/s/1kUwBh8j clover原始版，http://pan.baidu.com/s/1pKeSbMj Transmac.exe，http://pan.baidu.com/s/1i4o7EfV 二、安装 使用Transmac将原版镜像写入U盘 解压clover至U盘EFI分区 安装完成 三、驱动安装完成后USB3.0、触摸板默认驱动，kext文件夹放入了VoodooPS2Controller.kext所以键鼠驱动正常（该clover开启了InjectKext:detect，在sle下没有FakeSMC.kext的情况下是会注入Clover里的驱动的，后面会把它改成Yes来默认注入）。需要驱动的设备有 显卡HD4600，独显无解 声卡（使用万能声卡） 有线网卡RTL8111 无线网卡无解，使用小度wifi替代（USB无线网卡） 那么首先使用集成工具Hackintosh Vietnam Tool.dmg http://yun.baidu.com/s/1o708FLw来安装万能声卡和有线网卡（安装时自主勾选所需驱动），顺便可以把kext wizard或者kext unity（不推荐）也装一下，还有MaciASL和IORegistryExplorer也可以装一下，后面会用到。 接下来驱动小度wifi，驱动下载地址 http://pan.baidu.com/s/1hryJfIs，驱动方法里面也有，只是kext经常安上去不加载，推荐直接放到clover里然后开启驱动注入（同时把FakeSMC和VoodooPS2Controller装到SLE下）。 接下来就到显卡驱动啦，HD4600大概有两种方法，第一种方法是使用clover注入ig-platform-id，第二种是使用DSDT补丁的方法注入，因为要出现小太阳需要修改DSDT，所以推荐第二种，不过两种都说一下吧。 使用第一种方法的话，只需要在clover configrator（网上很好找，自行下载）里配置一下config.plist，勾选inject EDID、inject intel，然后在intelGFX和ig-platform-id里填上对应的值就行了（提供的clover里已经填好了适用于HD4600的），同时这里有适用于各种显卡的config.plist提供下载，笔记本安装通用clover配置文件http://pan.baidu.com/s/1qXrbtQ8。 第二种方法的话，方法比较复杂，不过有现成的视频教程，跟着一步一步做就行啦，提供远景原帖授权翻译 给DSDT/SSDT打补丁，实现笔记本亮度调节。 经过上面的折腾，一个比较稳定可以使用的黑苹果酒诞生啦，原生电源管理只能留到以后再完善啦~","categories":[],"tags":[{"name":"OS-X","slug":"OS-X","permalink":"http://ensorrow.github.io/tags/OS-X/"},{"name":"黑苹果","slug":"黑苹果","permalink":"http://ensorrow.github.io/tags/黑苹果/"}],"keywords":[]}]}